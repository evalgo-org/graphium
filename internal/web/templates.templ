package web

import (
	"fmt"
	"time"
	"evalgo.org/graphium/models"
	"evalgo.org/graphium/internal/storage"
	"evalgo.org/graphium/internal/config"
)

// Base layout template (for backward compatibility - no user param)
templ Layout(title string) {
	@LayoutWithUser(title, nil)
}

// Base layout template with optional user parameter
templ LayoutWithUser(title string, user *models.User) {
	<!DOCTYPE html>
	<html lang="en">
	<head>
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
		<title>{ title } - Graphium</title>
		<script src="https://unpkg.com/htmx.org@1.9.10"></script>
		<script src="https://unpkg.com/htmx.org/dist/ext/ws.js"></script>
		<link rel="stylesheet" href="/static/css/styles.css"/>
	</head>
	<body>
		<nav class="navbar">
			<div class="nav-brand">
				<h1>üß¨ Graphium</h1>
				<p class="tagline">Container Intelligence Platform</p>
			</div>
			<ul class="nav-links">
				<li><a href="/" class="nav-link">Dashboard</a></li>
				<li><a href="/web/containers" class="nav-link">Containers</a></li>
				<li><a href="/web/hosts" class="nav-link">Hosts</a></li>
				<li><a href="/web/agents" class="nav-link">Agents</a></li>
				<li><a href="/web/stacks" class="nav-link">Stacks</a></li>
				<li><a href="/web/graph" class="nav-link">Graph</a></li>
				<li><a href="/web/topology" class="nav-link">Topology</a></li>
			</ul>
			<div class="nav-user">
				if user != nil {
					<span class="user-name">üë§ { user.Username }</span>
					if user.IsAdmin() {
						<a href="/web/users" class="nav-link">Users</a>
					}
					<a href="/web/profile" class="nav-link">Profile</a>
					<a href="/web/auth/logout" class="nav-link">Logout</a>
				} else {
					<a href="/web/auth/login" class="nav-link">Login</a>
				}
			</div>
		</nav>
		<main class="container">
			{ children... }
		</main>
		<footer class="footer">
			<p>Graphium - Semantic Container Orchestration</p>
		</footer>

		<!-- Confirmation Modal -->
		<div id="confirmModal" class="modal" style="display: none;">
			<div class="modal-content">
				<div class="modal-header">
					<h3 id="confirmModalTitle">Confirm Action</h3>
				</div>
				<div class="modal-body">
					<p id="confirmModalMessage"></p>
				</div>
				<div class="modal-footer">
					<button type="button" class="btn btn-secondary" onclick="closeConfirmModal()">Cancel</button>
					<button type="button" class="btn btn-danger" id="confirmModalButton">Delete</button>
				</div>
			</div>
		</div>

		<!-- Theme Toggle Button -->
		<button class="theme-toggle" id="themeToggle" aria-label="Toggle theme">
			<span class="sun-icon">‚òÄÔ∏è</span>
			<span class="moon-icon">üåô</span>
		</button>

		<script>
			// Confirmation Modal Functions
			let confirmCallback = null;

			function showConfirmModal(title, message, buttonText, callback) {
				document.getElementById('confirmModalTitle').textContent = title;
				document.getElementById('confirmModalMessage').textContent = message;
				document.getElementById('confirmModalButton').textContent = buttonText || 'Delete';
				confirmCallback = callback;
				document.getElementById('confirmModal').style.display = 'flex';
			}

			function closeConfirmModal() {
				document.getElementById('confirmModal').style.display = 'none';
				confirmCallback = null;
			}

			document.getElementById('confirmModalButton').addEventListener('click', function() {
				if (confirmCallback) {
					confirmCallback();
				}
				closeConfirmModal();
			});

			// Close modal on background click
			document.getElementById('confirmModal').addEventListener('click', function(e) {
				if (e.target === this) {
					closeConfirmModal();
				}
			});
		</script>

		<script>
			// Theme toggle functionality
			(function() {
				const themeToggle = document.getElementById('themeToggle');
				const htmlElement = document.documentElement;

				// Check for saved theme preference or default to 'dark'
				const currentTheme = localStorage.getItem('theme') || 'dark';
				if (currentTheme === 'light') {
					htmlElement.setAttribute('data-theme', 'light');
				}

				// Toggle theme on button click
				themeToggle.addEventListener('click', function() {
					const theme = htmlElement.getAttribute('data-theme');
					if (theme === 'light') {
						htmlElement.removeAttribute('data-theme');
						localStorage.setItem('theme', 'dark');
					} else {
						htmlElement.setAttribute('data-theme', 'light');
						localStorage.setItem('theme', 'light');
					}
				});
			})();
		</script>
	</body>
	</html>
}

// Dashboard template (with user)
templ DashboardWithUser(stats *storage.Statistics, user *models.User) {
	@LayoutWithUser("Dashboard", user) {
		<div class="dashboard">
			<h2>Infrastructure Overview</h2>

			<div class="stats-grid">
				<div class="stat-card">
					<div class="stat-icon">üì¶</div>
					<div class="stat-content">
						<h3>Total Containers</h3>
						<p class="stat-value" id="stat-total-containers">{ fmt.Sprintf("%d", stats.TotalContainers) }</p>
					</div>
				</div>

				<div class="stat-card stat-success">
					<div class="stat-icon">‚ñ∂Ô∏è</div>
					<div class="stat-content">
						<h3>Running</h3>
						<p class="stat-value" id="stat-running-containers">{ fmt.Sprintf("%d", stats.RunningContainers) }</p>
					</div>
				</div>

				<div class="stat-card">
					<div class="stat-icon">üñ•Ô∏è</div>
					<div class="stat-content">
						<h3>Total Hosts</h3>
						<p class="stat-value" id="stat-total-hosts">{ fmt.Sprintf("%d", stats.TotalHosts) }</p>
					</div>
				</div>

				<div class="stat-card">
					<div class="stat-icon">üìö</div>
					<div class="stat-content">
						<h3>Total Stacks</h3>
						<p class="stat-value" id="stat-total-stacks">{ fmt.Sprintf("%d", stats.TotalStacks) }</p>
					</div>
				</div>

				<div class="stat-card stat-success">
					<div class="stat-icon">üöÄ</div>
					<div class="stat-content">
						<h3>Running Stacks</h3>
						<p class="stat-value" id="stat-running-stacks">{ fmt.Sprintf("%d", stats.RunningStacks) }</p>
					</div>
				</div>

				<div class="stat-card stat-info">
					<div class="stat-icon">üìä</div>
					<div class="stat-content">
						<h3>Hosts with Containers</h3>
						<p class="stat-value" id="stat-hosts-with-containers">{ fmt.Sprintf("%d", len(stats.HostContainerCounts)) }</p>
					</div>
				</div>
			</div>



		</div>
		<script>
			(function() {
				// WebSocket connection for real-time dashboard updates
				let ws = null;
				let wsReconnectAttempts = 0;
				const maxReconnectAttempts = 10;
				const reconnectDelay = 3000;

				function connectWebSocket() {
					const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
					const wsURL = `${protocol}//${window.location.host}/api/v1/ws/graph`;

					try {
						ws = new WebSocket(wsURL);

						ws.onopen = function() {
							console.log('Dashboard WebSocket connected');
							wsReconnectAttempts = 0;
						};

						ws.onmessage = function(event) {
							try {
								const graphEvent = JSON.parse(event.data);
								console.log('Dashboard received event:', graphEvent.type);

								// Refresh stats on any container/host/stack change
								if (graphEvent.type === 'container_added' ||
									graphEvent.type === 'container_removed' ||
									graphEvent.type === 'container_updated' ||
									graphEvent.type === 'host_added' ||
									graphEvent.type === 'host_removed' ||
									graphEvent.type === 'stack_added' ||
									graphEvent.type === 'stack_removed') {
									refreshStats();
								}
							} catch (error) {
								console.error('Failed to parse WebSocket message:', error);
							}
						};

						ws.onerror = function(error) {
							console.error('Dashboard WebSocket error:', error);
						};

						ws.onclose = function() {
							console.log('Dashboard WebSocket disconnected');
							// Attempt to reconnect
							if (wsReconnectAttempts < maxReconnectAttempts) {
								wsReconnectAttempts++;
								console.log(`Reconnecting dashboard WebSocket (attempt ${wsReconnectAttempts}/${maxReconnectAttempts})...`);
								setTimeout(connectWebSocket, reconnectDelay);
							} else {
								console.error('Max dashboard WebSocket reconnection attempts reached');
							}
						};
					} catch (error) {
						console.error('Failed to create dashboard WebSocket connection:', error);
					}
				}

				// Fetch and update statistics
				function refreshStats() {
					console.log('üîÑ Refreshing stats from /api/v1/stats...');
					fetch('/api/v1/stats', {
						credentials: 'same-origin'
					})
						.then(response => {
							console.log('üìä Stats API response status:', response.status);
							if (!response.ok) {
								throw new Error(`HTTP ${response.status}: ${response.statusText}`);
							}
							return response.json();
						})
						.then(data => {
							console.log('‚úÖ Stats data received:', data);
							document.getElementById('stat-total-containers').textContent = data.totalContainers;
							document.getElementById('stat-running-containers').textContent = data.runningContainers;
							document.getElementById('stat-total-hosts').textContent = data.totalHosts;
							document.getElementById('stat-total-stacks').textContent = data.totalStacks || 0;
							document.getElementById('stat-running-stacks').textContent = data.runningStacks || 0;
							document.getElementById('stat-hosts-with-containers').textContent = data.hostsWithContainers || 0;
							console.log('‚úÖ Dashboard DOM updated with new stats');
						})
						.catch(error => {
							console.error('‚ùå Failed to refresh stats:', error);
						});
				}

				// Connect WebSocket on page load
				connectWebSocket();

				// Also refresh stats immediately on page load (in case data changed while on another page)
				refreshStats();
			})();
		</script>
	}
}

// Pagination component
templ Pagination(pagination PaginationInfo, baseURL string, queryParams string) {
	<div class="pagination">
		<div class="pagination-info">
			Showing { fmt.Sprintf("%d-%d", (pagination.Page-1)*pagination.PageSize+1, min((pagination.Page-1)*pagination.PageSize+pagination.PageSize, pagination.TotalItems)) } of { fmt.Sprintf("%d", pagination.TotalItems) }
		</div>
		<div class="pagination-controls">
			if pagination.HasPrev {
				if queryParams != "" {
					<a href={ templ.URL(fmt.Sprintf("%s?%s&page=%d", baseURL, queryParams, pagination.Page-1)) } class="btn btn-secondary">‚Üê Previous</a>
				} else {
					<a href={ templ.URL(fmt.Sprintf("%s?page=%d", baseURL, pagination.Page-1)) } class="btn btn-secondary">‚Üê Previous</a>
				}
			} else {
				<span class="btn btn-secondary disabled">‚Üê Previous</span>
			}
			<span class="pagination-current">Page { fmt.Sprintf("%d", pagination.Page) } of { fmt.Sprintf("%d", pagination.TotalPages) }</span>
			if pagination.HasNext {
				if queryParams != "" {
					<a href={ templ.URL(fmt.Sprintf("%s?%s&page=%d", baseURL, queryParams, pagination.Page+1)) } class="btn btn-secondary">Next ‚Üí</a>
				} else {
					<a href={ templ.URL(fmt.Sprintf("%s?page=%d", baseURL, pagination.Page+1)) } class="btn btn-secondary">Next ‚Üí</a>
				}
			} else {
				<span class="btn btn-secondary disabled">Next ‚Üí</span>
			}
		</div>
	</div>
}

// Containers list template (with user)
templ ContainersListWithUser(containers []*models.Container, stackMap map[string]*models.Stack, pagination PaginationInfo, errorMsg string, user *models.User) {
	@LayoutWithUser("Containers", user) {
		if errorMsg != "" {
			<div class="alert alert-error" style="margin: 20px; padding: 15px; background-color: #fee; border: 1px solid #fcc; border-radius: 4px; color: #c00;">
				{ errorMsg }
			</div>
		}
		<div class="page-header">
			<h2>Containers</h2>
			<div class="filters">
				<div class="bulk-actions-left">
					<span id="selected-count" class="selected-count">0 selected</span>
					<select id="bulk-action-select" class="action-select">
						<option value="">Select action...</option>
						<option value="assign-stack">Assign to Stack</option>
						<option value="delete">Delete</option>
						<option value="stop">Stop</option>
						<option value="start">Start</option>
						<option value="restart">Restart</option>
					</select>
					<button onclick="executeBulkAction()" class="btn btn-primary">Execute</button>
					<button onclick="clearSelection()" class="btn btn-secondary">Clear</button>
				</div>
				<div class="bulk-actions-right">
					<input
						type="text"
						name="search"
						class="search-input"
						placeholder="Search by name..."
						hx-get="/web/containers/table"
						hx-target="#containers-table"
						hx-trigger="keyup changed delay:300ms"
						hx-include="[name='status']"
					/>
					<select name="status" class="status-select" hx-get="/web/containers/table" hx-target="#containers-table" hx-trigger="change" hx-include="[name='search']">
						<option value="">All Statuses</option>
						<option value="running">Running</option>
						<option value="stopped">Stopped</option>
						<option value="paused">Paused</option>
						<option value="exited">Exited</option>
					</select>
				</div>
			</div>
		</div>

		<div id="containers-table">
			@ContainersTableWithPagination(containers, stackMap, pagination, "")
		</div>

		<!-- Confirmation Modal -->
		<div id="confirmModal" class="modal">
			<div class="modal-content">
				<div class="modal-header">
					<h3 class="modal-title" id="confirmModalTitle">Confirm Action</h3>
					<button class="modal-close" onclick="closeModal('confirmModal')">&times;</button>
				</div>
				<div class="modal-body" id="confirmModalBody"></div>
				<div class="modal-footer">
					<button class="btn btn-secondary" onclick="closeModal('confirmModal')">Cancel</button>
					<button class="btn btn-primary" id="confirmModalConfirm">Confirm</button>
				</div>
			</div>
		</div>

		<!-- Alert Modal -->
		<div id="alertModal" class="modal">
			<div class="modal-content">
				<div class="modal-header">
					<h3 class="modal-title" id="alertModalTitle">Notice</h3>
					<button class="modal-close" onclick="closeModal('alertModal')">&times;</button>
				</div>
				<div class="modal-body" id="alertModalBody"></div>
				<div class="modal-footer">
					<button class="btn btn-primary" onclick="closeModal('alertModal')">OK</button>
				</div>
			</div>
		</div>

		<!-- Assign to Stack Modal -->
		<div id="assignStackModal" class="modal">
			<div class="modal-content">
				<div class="modal-header">
					<h3 class="modal-title">Assign to Stack</h3>
					<button class="modal-close" onclick="closeModal('assignStackModal')">&times;</button>
				</div>
				<div class="modal-body">
					<p id="assign-stack-message"></p>
					<select id="stack-selector" class="action-select" style="width: 100%; margin-top: 1rem;">
						<option value="">Select a stack...</option>
					</select>
				</div>
				<div class="modal-footer">
					<button class="btn btn-secondary" onclick="closeModal('assignStackModal')">Cancel</button>
					<button class="btn btn-primary" id="assignStackConfirm">Assign</button>
				</div>
			</div>
		</div>

		<script>
			// Modal helper functions
			function showModal(modalId) {
				const modal = document.getElementById(modalId);
				if (modal) modal.classList.add('active');
			}

			function closeModal(modalId) {
				const modal = document.getElementById(modalId);
				if (modal) modal.classList.remove('active');
			}

			function showAlert(title, message, callback) {
				document.getElementById('alertModalTitle').textContent = title;
				document.getElementById('alertModalBody').innerHTML = message.replace(/\\n/g, '<br>');
				showModal('alertModal');
				const okBtn = document.querySelector('#alertModal .btn-primary');
				okBtn.onclick = function() {
					closeModal('alertModal');
					if (callback) callback();
				};
			}

			function showConfirm(title, message, onConfirm) {
				document.getElementById('confirmModalTitle').textContent = title;
				document.getElementById('confirmModalBody').innerHTML = message.replace(/\\n/g, '<br>');
				showModal('confirmModal');
				const confirmBtn = document.getElementById('confirmModalConfirm');
				confirmBtn.onclick = function() {
					closeModal('confirmModal');
					if (onConfirm) onConfirm();
				};
			}

			window.onclick = function(event) {
				if (event.target.classList.contains('modal')) {
					event.target.classList.remove('active');
				}
			};

			// Multi-select functionality for containers
			function toggleSelectAll(checkbox) {
				const checkboxes = document.querySelectorAll('.container-checkbox');
				checkboxes.forEach(cb => {
					cb.checked = checkbox.checked;
				});
				updateBulkActions();
			}

			function updateBulkActions() {
				const checkboxes = document.querySelectorAll('.container-checkbox:checked');
				const selectedCount = document.getElementById('selected-count');

				if (checkboxes.length > 0) {
					selectedCount.textContent = `${checkboxes.length} selected`;
				} else {
					selectedCount.textContent = '0 selected';
					// Reset dropdown
					const actionSelect = document.getElementById('bulk-action-select');
					if (actionSelect) {
						actionSelect.value = '';
					}
				}

				// Update "select all" checkbox state
				const allCheckboxes = document.querySelectorAll('.container-checkbox');
				const selectAllCheckbox = document.getElementById('select-all');
				if (selectAllCheckbox) {
					selectAllCheckbox.checked = allCheckboxes.length > 0 && checkboxes.length === allCheckboxes.length;
				}
			}

			function clearSelection() {
				const checkboxes = document.querySelectorAll('.container-checkbox');
				checkboxes.forEach(cb => {
					cb.checked = false;
				});
				const selectAllCheckbox = document.getElementById('select-all');
				if (selectAllCheckbox) {
					selectAllCheckbox.checked = false;
				}
				updateBulkActions();
			}

			function getSelectedContainerIds() {
				const checkboxes = document.querySelectorAll('.container-checkbox:checked');
				return Array.from(checkboxes).map(cb => cb.dataset.containerId);
			}

			function executeBulkAction() {
				const actionSelect = document.getElementById('bulk-action-select');
				const action = actionSelect.value;

				if (!action) {
					showAlert('No Action Selected', 'Please select an action from the dropdown');
					return;
				}

				const containerIds = getSelectedContainerIds();
				if (containerIds.length === 0) {
					showAlert('No Containers Selected', 'Please select at least one container');
					return;
				}

				// Route to appropriate action handler
				switch (action) {
					case 'assign-stack':
						showAssignStackModal(containerIds);
						break;
					case 'delete':
						bulkDeleteContainers(containerIds);
						break;
					case 'stop':
						bulkStopContainers(containerIds);
						break;
					case 'start':
						bulkStartContainers(containerIds);
						break;
					case 'restart':
						bulkRestartContainers(containerIds);
						break;
					default:
						showAlert('Unknown Action', 'Unknown action: ' + action);
				}
			}

			function showAssignStackModal(containerIds) {
				const count = containerIds.length;
				document.getElementById('assign-stack-message').textContent = `Assign ${count} container${count > 1 ? 's' : ''} to a stack:`;

				// Fetch available stacks
				fetch('/web/stacks/json', {
					credentials: 'same-origin'
				})
				.then(response => {
					if (!response.ok) {
						throw new Error(`HTTP ${response.status}: ${response.statusText}`);
					}
					return response.json();
				})
				.then(stacks => {
					if (!Array.isArray(stacks)) {
						throw new Error('Invalid response format');
					}

					const selector = document.getElementById('stack-selector');
					selector.innerHTML = '<option value="">Select a stack...</option>';

					if (stacks.length === 0) {
						showAlert('No Stacks Available', 'Please create a stack first before assigning containers');
						return;
					}

					stacks.forEach(stack => {
						const option = document.createElement('option');
						option.value = stack.id;
						option.textContent = stack.name;
						selector.appendChild(option);
					});

					showModal('assignStackModal');

					document.getElementById('assignStackConfirm').onclick = function() {
						const stackId = selector.value;
						if (!stackId) {
							showAlert('No Stack Selected', 'Please select a stack');
							return;
						}
						assignContainersToStack(containerIds, stackId);
					};
				})
				.catch(error => {
					showAlert('Error', 'Failed to load stacks: ' + error.message);
				});
			}

			function assignContainersToStack(containerIds, stackId) {
				closeModal('assignStackModal');

				fetch(`/web/stacks/${stackId}/containers/assign`, {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
					},
					body: JSON.stringify({ container_ids: containerIds }),
					credentials: 'same-origin'
				})
				.then(response => response.json())
				.then(data => {
					if (data.success) {
						showAlert('Success', `Successfully assigned ${data.count} container(s) to stack`, function() {
							window.location.reload();
						});
					} else {
						showAlert('Error', data.error || 'Failed to assign containers to stack');
					}
				})
				.catch(error => {
					showAlert('Error', 'Failed to assign containers: ' + error.message);
				});
			}

			function bulkDeleteContainers(containerIds) {
				const count = containerIds.length;
				const message = `Are you sure you want to delete ${count} container${count > 1 ? 's' : ''}?<br><br>This will:<br>- Remove the container(s) from Docker<br>- Remove the container(s) from the database<br><br>This action cannot be undone.`;

				showConfirm('Confirm Deletion', message, function() {
					performBulkAction('/web/containers/bulk/delete', { container_ids: containerIds }, 'Deleting', 'deleted');
				});
			}

			function bulkStopContainers(containerIds) {
				const count = containerIds.length;
				showConfirm('Confirm Stop', `Stop ${count} container${count > 1 ? 's' : ''}?`, function() {
					performBulkAction('/web/containers/bulk/stop', { container_ids: containerIds }, 'Stopping', 'stopped');
				});
			}

			function bulkStartContainers(containerIds) {
				const count = containerIds.length;
				showConfirm('Confirm Start', `Start ${count} container${count > 1 ? 's' : ''}?`, function() {
					performBulkAction('/web/containers/bulk/start', { container_ids: containerIds }, 'Starting', 'started');
				});
			}

			function bulkRestartContainers(containerIds) {
				const count = containerIds.length;
				showConfirm('Confirm Restart', `Restart ${count} container${count > 1 ? 's' : ''}?`, function() {
					performBulkAction('/web/containers/bulk/restart', { container_ids: containerIds }, 'Restarting', 'restarted');
				});
			}

			function performBulkAction(url, body, actioningText, actionedText) {
				const executeBtn = document.querySelector('.bulk-actions-left .btn-primary');
				const originalText = executeBtn.textContent;
				executeBtn.disabled = true;
				executeBtn.textContent = actioningText + '...';

				fetch(url, {
					method: 'POST',
					headers: {
						'Content-Type': 'application/json',
					},
					body: JSON.stringify(body),
					credentials: 'same-origin'
				})
				.then(response => response.json())
				.then(data => {
					executeBtn.disabled = false;
					executeBtn.textContent = originalText;

					if (data.success) {
						showAlert('Success', `Successfully ${actionedText} ${data.success_count || data.deleted_count || body.container_ids.length} container(s)`, function() {
							window.location.reload();
						});
					} else {
						const errorMsg = `Error: ${data.error}<br><br>Success: ${data.success_count || data.deleted_count || 0}<br>Failed: ${data.failed_count || 0}`;
						showAlert('Error', errorMsg, function() {
							window.location.reload();
						});
					}
				})
				.catch(error => {
					executeBtn.disabled = false;
					executeBtn.textContent = originalText;
					showAlert('Error', `Failed to ${actionedText.replace('ed', '')} containers: ${error.message}`);
				});
			}

			// Restore checkbox states after HTMX updates
			document.body.addEventListener('htmx:afterSwap', function(event) {
				if (event.detail.target.id === 'containers-table') {
					// Clear selections after table refresh
					clearSelection();
				}
			});
		</script>
	}
}

// Containers table component (for HTMX updates)
templ ContainersTable(containers []*models.Container, stackMap map[string]*models.Stack) {
	<div class="table-container">
		<table class="data-table">
			<thead>
				<tr>
					<th style="width: 40px;">
						<input type="checkbox" id="select-all" onclick="toggleSelectAll(this)" title="Select all" style="cursor: pointer; width: 16px; height: 16px;"/>
					</th>
					<th>Name</th>
					<th>Image</th>
					<th>Status</th>
					<th>Stack</th>
					<th>Host</th>
					<th>Created</th>
				</tr>
			</thead>
			<tbody>
				if len(containers) == 0 {
					<tr>
						<td colspan="7" class="no-data">No containers found</td>
					</tr>
				}
				for _, container := range containers {
					<tr>
						<td>
							<input
								type="checkbox"
								class="container-checkbox"
								data-container-id={ container.ID }
								data-container-name={ container.Name }
								data-container-status={ container.Status }
								onclick="updateBulkActions()"
								style="cursor: pointer; width: 16px; height: 16px;"
							/>
						</td>
						<td>
							<a href={ templ.URL(fmt.Sprintf("/web/containers/%s", container.ID)) } style="text-decoration: none; color: inherit;">
								<strong>{ container.Name }</strong>
							</a>
							<br/>
							<small class="text-muted">{ container.ID[:12] }</small>
						</td>
						<td>{ container.Image }</td>
						<td>
							<span class={ fmt.Sprintf("badge badge-%s", container.Status) }>
								{ container.Status }
							</span>
						</td>
						<td>
							if stackMap != nil {
								if stack, ok := stackMap[container.ID]; ok {
									<a href={ templ.URL(fmt.Sprintf("/web/stacks/%s", stack.ID)) } title={ fmt.Sprintf("Part of stack: %s", stack.Name) }>
										üì¶
									</a>
								} else {
									<span class="text-muted">-</span>
								}
							} else {
								<span class="text-muted">-</span>
							}
						</td>
						<td>{ container.HostedOn }</td>
						<td>{ container.Created }</td>
					</tr>
				}
			</tbody>
		</table>
		<div class="table-footer">
			<p>Total: { fmt.Sprintf("%d", len(containers)) } containers</p>
		</div>
	</div>
}

// Containers table with pagination (for HTMX updates)
templ ContainersTableWithPagination(containers []*models.Container, stackMap map[string]*models.Stack, pagination PaginationInfo, queryParams string) {
	<div class="table-container">
		<table class="data-table">
			<thead>
				<tr>
					<th style="width: 40px;">
						<input type="checkbox" id="select-all" onclick="toggleSelectAll(this)" title="Select all" style="cursor: pointer; width: 16px; height: 16px;"/>
					</th>
					<th>Name</th>
					<th>Image</th>
					<th>Status</th>
					<th>Stack</th>
					<th>Host</th>
					<th>Created</th>
				</tr>
			</thead>
			<tbody>
				if len(containers) == 0 {
					<tr>
						<td colspan="7" class="no-data">No containers found</td>
					</tr>
				}
				for _, container := range containers {
					<tr>
						<td>
							<input
								type="checkbox"
								class="container-checkbox"
								data-container-id={ container.ID }
								data-container-name={ container.Name }
								data-container-status={ container.Status }
								onclick="updateBulkActions()"
								style="cursor: pointer; width: 16px; height: 16px;"
							/>
						</td>
						<td>
							<a href={ templ.URL(fmt.Sprintf("/web/containers/%s", container.ID)) } style="text-decoration: none; color: inherit;">
								<strong>{ container.Name }</strong>
							</a>
							<br/>
							<small class="text-muted">{ container.ID[:12] }</small>
						</td>
						<td>{ container.Image }</td>
						<td>
							<span class={ fmt.Sprintf("badge badge-%s", container.Status) }>
								{ container.Status }
							</span>
						</td>
						<td>
							if stackMap != nil {
								if stack, ok := stackMap[container.ID]; ok {
									<a href={ templ.URL(fmt.Sprintf("/web/stacks/%s", stack.ID)) } title={ fmt.Sprintf("Part of stack: %s", stack.Name) }>
										üì¶
									</a>
								} else {
									<span class="text-muted">-</span>
								}
							} else {
								<span class="text-muted">-</span>
							}
						</td>
						<td>{ container.HostedOn }</td>
						<td>{ container.Created }</td>
					</tr>
				}
			</tbody>
		</table>
		@Pagination(pagination, "/web/containers", queryParams)
	</div>
}

// Hosts list template (with user)
templ HostsListWithUser(hosts []*models.Host, pagination PaginationInfo, user *models.User) {
	@LayoutWithUser("Hosts", user) {
		<div class="page-header">
			<h2>Hosts</h2>
			<div class="filters">
				<a href="/web/hosts/new" class="btn btn-primary">+ Create Host</a>
				<input
					type="text"
					name="search"
					class="search-input"
					placeholder="Search by name..."
					hx-get="/web/hosts/table"
					hx-target="#hosts-table"
					hx-trigger="keyup changed delay:300ms"
					hx-include="[name='status']"
				/>
				<select name="status" hx-get="/web/hosts/table" hx-target="#hosts-table" hx-trigger="change" hx-include="[name='search']">
					<option value="">All Statuses</option>
					<option value="active">Active</option>
					<option value="inactive">Inactive</option>
					<option value="maintenance">Maintenance</option>
				</select>
			</div>
		</div>

		<div id="hosts-table">
			@HostsTableWithPagination(hosts, pagination, "")
		</div>
	}
}

// Hosts table component (for HTMX updates)
templ HostsTable(hosts []*models.Host) {
	<div class="table-container">
		<table class="data-table">
			<thead>
				<tr>
					<th>Name</th>
					<th>IP Address</th>
					<th>CPU</th>
					<th>Memory</th>
					<th>Status</th>
					<th>Datacenter</th>
					<th>Actions</th>
				</tr>
			</thead>
			<tbody>
				if len(hosts) == 0 {
					<tr>
						<td colspan="7" class="no-data">No hosts found</td>
					</tr>
				}
				for _, host := range hosts {
					<tr>
						<td>
							<strong>{ host.Name }</strong>
							<br/>
							<small class="text-muted">{ host.ID }</small>
						</td>
						<td>{ host.IPAddress }</td>
						<td>{ fmt.Sprintf("%d cores", host.CPU) }</td>
						<td>{ fmt.Sprintf("%.1f GB", float64(host.Memory) / 1024 / 1024 / 1024) }</td>
						<td>
							<span class={ fmt.Sprintf("badge badge-%s", host.Status) }>
								{ host.Status }
							</span>
						</td>
						<td>{ host.Datacenter }</td>
						<td>
							<div class="action-buttons">
								<a href={ templ.URL(fmt.Sprintf("/web/hosts/%s", host.ID)) } class="btn-icon" title="View Details">üëÅÔ∏è</a>
								<a href={ templ.URL(fmt.Sprintf("/web/containers?host=%s", host.ID)) } class="btn-icon" title="View Containers">üì¶</a>
							</div>
						</td>
					</tr>
				}
			</tbody>
		</table>
		<div class="table-footer">
			<p>Total: { fmt.Sprintf("%d", len(hosts)) } hosts</p>
		</div>
	</div>
}

// Hosts table with pagination (for HTMX updates)
templ HostsTableWithPagination(hosts []*models.Host, pagination PaginationInfo, queryParams string) {
	<div class="table-container">
		<table class="data-table">
			<thead>
				<tr>
					<th>Name</th>
					<th>IP Address</th>
					<th>CPU</th>
					<th>Memory</th>
					<th>Status</th>
					<th>Datacenter</th>
					<th>Actions</th>
				</tr>
			</thead>
			<tbody>
				if len(hosts) == 0 {
					<tr>
						<td colspan="7" class="no-data">No hosts found</td>
					</tr>
				}
				for _, host := range hosts {
					<tr>
						<td>
							<strong>{ host.Name }</strong>
							<br/>
							<small class="text-muted">{ host.ID }</small>
						</td>
						<td>{ host.IPAddress }</td>
						<td>{ fmt.Sprintf("%d cores", host.CPU) }</td>
						<td>{ fmt.Sprintf("%.1f GB", float64(host.Memory) / 1024 / 1024 / 1024) }</td>
						<td>
							<span class={ fmt.Sprintf("badge badge-%s", host.Status) }>
								{ host.Status }
							</span>
						</td>
						<td>{ host.Datacenter }</td>
						<td>
							<div class="action-buttons">
								<a href={ templ.URL(fmt.Sprintf("/web/hosts/%s", host.ID)) } class="btn-icon" title="View Details">üëÅÔ∏è</a>
								<a href={ templ.URL(fmt.Sprintf("/web/containers?host=%s", host.ID)) } class="btn-icon" title="View Containers">üì¶</a>
							</div>
						</td>
					</tr>
				}
			</tbody>
		</table>
		@Pagination(pagination, "/web/hosts", queryParams)
	</div>
}

// Topology view template (with user)
templ TopologyViewWithUser(topology *storage.DatacenterTopology, topologies map[string]*storage.DatacenterTopology, datacenters map[string]bool, datacenter string, user *models.User) {
	@LayoutWithUser("Topology", user) {
		<div class="page-header">
			<h2>Infrastructure Topology</h2>
			<div class="filters">
				<select name="datacenter" hx-get="/web/topology" hx-target="main .container" hx-include="[name='datacenter']">
					<option value="all" selected?={ datacenter == "all" }>All Datacenters</option>
					for dc := range datacenters {
						<option value={ dc } selected?={ datacenter == dc }>{ dc }</option>
					}
				</select>
			</div>
		</div>

		if topology != nil {
			<!-- Single Datacenter View -->
			<div class="topology-view">
				<div class="datacenter-section">
					<h3 class="datacenter-title">üìç { topology.Datacenter }</h3>
					<div class="topology-grid">
						for hostID, hostTopo := range topology.Hosts {
							<div class="host-card">
								<div class="host-header">
									<h4>
										<a href={ templ.URL(fmt.Sprintf("/web/hosts/%s", hostID)) }>üñ•Ô∏è { hostTopo.Host.Name }</a>
									</h4>
									<span class={ fmt.Sprintf("badge badge-%s", hostTopo.Host.Status) }>
										{ hostTopo.Host.Status }
									</span>
								</div>
								<div class="host-details">
									<p><strong>IP:</strong> { hostTopo.Host.IPAddress }</p>
									<p><strong>CPU:</strong> { fmt.Sprintf("%d cores", hostTopo.Host.CPU) }</p>
									<p><strong>Memory:</strong> { fmt.Sprintf("%.1f GB", float64(hostTopo.Host.Memory) / 1024 / 1024 / 1024) }</p>
								</div>
								<div class="containers-section">
									<h5>
										Containers:
										if hostTopo.ContainerCount > 0 {
											<a href={ templ.URL(fmt.Sprintf("/web/containers?host=%s", hostID)) }>
												{ fmt.Sprintf("%d", hostTopo.ContainerCount) }
											</a>
										} else {
											<span>0</span>
										}
									</h5>
								</div>
							</div>
						}
					</div>
				</div>
			</div>
		} else if topologies != nil && len(topologies) > 0 {
			<!-- All Datacenters View -->
			<div class="topology-view">
				for dcName, dcTopo := range topologies {
					<div class="datacenter-section">
						<h3 class="datacenter-title">üìç { dcName }</h3>
						<div class="topology-grid">
							for hostID, hostTopo := range dcTopo.Hosts {
								<div class="host-card">
									<div class="host-header">
										<h4>
											<a href={ templ.URL(fmt.Sprintf("/web/hosts/%s", hostID)) }>üñ•Ô∏è { hostTopo.Host.Name }</a>
										</h4>
										<span class={ fmt.Sprintf("badge badge-%s", hostTopo.Host.Status) }>
											{ hostTopo.Host.Status }
										</span>
									</div>
									<div class="host-details">
										<p><strong>IP:</strong> { hostTopo.Host.IPAddress }</p>
										<p><strong>CPU:</strong> { fmt.Sprintf("%d cores", hostTopo.Host.CPU) }</p>
										<p><strong>Memory:</strong> { fmt.Sprintf("%.1f GB", float64(hostTopo.Host.Memory) / 1024 / 1024 / 1024) }</p>
									</div>
									<div class="containers-section">
										<h5>
											Containers:
											if hostTopo.ContainerCount > 0 {
												<a href={ templ.URL(fmt.Sprintf("/web/containers?host=%s", hostID)) }>
													{ fmt.Sprintf("%d", hostTopo.ContainerCount) }
												</a>
											} else {
												<span>0</span>
											}
										</h5>
									</div>
								</div>
							}
						</div>
					</div>
				}
			</div>
		} else {
			<div class="empty-state">
				<div class="empty-icon">üìä</div>
				<h3>No Infrastructure Data</h3>
				<p>No hosts or containers found. Start the agent to begin monitoring your infrastructure.</p>
			</div>
		}
	}
}

// Graph visualization template (with user)
templ GraphViewWithUser(cfg *config.Config, user *models.User) {
	@LayoutWithUser("Graph Visualization", user) {
		<div class="page-header">
			<h2>Infrastructure Graph</h2>
			<div class="filters">
				<div class="graph-control-group">
					<label for="layout-select">Layout:</label>
					<select id="layout-select" name="layout">
						<option value="cose">Force Directed (COSE)</option>
						<option value="grid">Grid</option>
						<option value="circle">Circle</option>
						<option value="breadthfirst">Hierarchical</option>
						<option value="concentric">Concentric</option>
					</select>
				</div>
				<div class="graph-control-group">
					<label for="filter-type">Node Type:</label>
					<select id="filter-type" name="type">
						<option value="all">All Types</option>
						<option value="host">Hosts Only</option>
						<option value="container">Containers Only</option>
					</select>
				</div>
				<div class="graph-control-group">
					<label for="filter-status">Status:</label>
					<select id="filter-status" name="status">
						<option value="all">All Status</option>
						<option value="running">Running</option>
						<option value="stopped">Stopped</option>
						<option value="paused">Paused</option>
					</select>
				</div>
				<div class="graph-control-group">
					<label for="filter-datacenter">Datacenter:</label>
					<select id="filter-datacenter" name="datacenter">
						<option value="all">All Datacenters</option>
					</select>
				</div>
				<button class="btn btn-secondary" id="btn-clear-filters">Clear Filters</button>
			</div>
		</div>

		<div class="graph-container">
			<div class="graph-legend">
				<div class="legend-item">
					<div class="legend-color host"></div>
					<span>Hosts</span>
				</div>
				<div class="legend-item">
					<div class="legend-color container-running"></div>
					<span>Running Containers</span>
				</div>
				<div class="legend-item">
					<div class="legend-color container-stopped"></div>
					<span>Stopped Containers</span>
				</div>
			</div>

			<div id="graph-stats" class="graph-stats">
				<div class="graph-stat-item">
					<div class="label">Total Nodes</div>
					<div class="value" id="stat-nodes">-</div>
				</div>
				<div class="graph-stat-item">
					<div class="label">Hosts</div>
					<div class="value" id="stat-hosts">-</div>
				</div>
				<div class="graph-stat-item">
					<div class="label">Containers</div>
					<div class="value" id="stat-containers">-</div>
				</div>
				<div class="graph-stat-item">
					<div class="label">Relationships</div>
					<div class="value" id="stat-edges">-</div>
				</div>
			</div>

			<div class="graph-controls">
				<div class="action-buttons">
					<button class="btn btn-primary" id="btn-fit">Fit to Screen</button>
					<button class="btn btn-secondary" id="btn-center">Center</button>
					<button class="btn btn-secondary" id="btn-refresh">Refresh Data</button>
					<button class="btn btn-secondary" id="btn-export-png">Export PNG</button>
					<button class="btn btn-secondary" id="btn-export-svg">Export SVG</button>
					<button class="btn btn-secondary" id="btn-export-json">Export JSON</button>
				</div>
			</div>

			<div id="cy"></div>
		</div>

		<script src="https://unpkg.com/cytoscape@3.26.0/dist/cytoscape.min.js"></script>
		<script>
		(function() {
			let cy;
			let originalData = { nodes: [], edges: [] };
			let currentFilters = { type: 'all', status: 'all', datacenter: 'all' };

			// Initialize Cytoscape
			function initGraph(layout = 'cose') {
				fetch('/api/v1/graph')
					.then(response => response.json())
					.then(data => {
						// Store original data
						originalData = {
							nodes: data.nodes || [],
							edges: data.edges || []
						};

						// Populate datacenter filter with unique datacenters
						populateDatacenterFilter(originalData.nodes);

						// Apply current filters
						const elements = applyFilters(originalData, currentFilters);

						// Update stats
						const stats = {
							nodes: elements.nodes.length,
							hosts: elements.nodes.filter(n => n.data.type === 'host').length,
							containers: elements.nodes.filter(n => n.data.type === 'container').length,
							edges: elements.edges.length
						};

						document.getElementById('stat-nodes').textContent = stats.nodes;
						document.getElementById('stat-hosts').textContent = stats.hosts;
						document.getElementById('stat-containers').textContent = stats.containers;
						document.getElementById('stat-edges').textContent = stats.edges;

						// Initialize or update graph
						if (cy) {
							cy.destroy();
						}

						cy = cytoscape({
							container: document.getElementById('cy'),
							elements: elements,
							style: [
								{
									selector: 'node',
									style: {
										'background-color': '#6366f1',
										'label': 'data(label)',
										'color': '#f1f5f9',
										'text-valign': 'center',
										'text-halign': 'center',
										'font-size': '12px',
										'width': 60,
										'height': 60,
										'border-width': 2,
										'border-color': '#8b5cf6'
									}
								},
								{
									selector: 'node[type="host"]',
									style: {
										'background-color': '#6366f1',
										'shape': 'rectangle',
										'width': 80,
										'height': 60,
										'border-color': '#4f46e5'
									}
								},
								{
									selector: 'node[type="container"]',
									style: {
										'background-color': '#10b981',
										'shape': 'ellipse',
										'width': 60,
										'height': 60
									}
								},
								{
									selector: 'node[status="stopped"]',
									style: {
										'background-color': '#94a3b8',
										'opacity': 0.7
									}
								},
								{
									selector: 'node[status="running"]',
									style: {
										'background-color': '#10b981'
									}
								},
								{
									selector: 'edge',
									style: {
										'width': 2,
										'line-color': '#475569',
										'target-arrow-color': '#475569',
										'target-arrow-shape': 'triangle',
										'curve-style': 'bezier',
										'arrow-scale': 1.5
									}
								},
								{
									selector: 'node:selected',
									style: {
										'border-width': 4,
										'border-color': '#f59e0b'
									}
								}
							],
							layout: {
								name: layout,
								animate: true,
								animationDuration: 500,
								fit: true,
								padding: 50,
								randomize: false,
								componentSpacing: 100,
								nodeRepulsion: 400000,
								idealEdgeLength: 100,
								edgeElasticity: 100
							}
						});

						// Add tooltips on hover
						cy.on('tap', 'node', function(evt) {
							const node = evt.target;
							const data = node.data();
							let info = `Type: ${data.type}\\nID: ${data.id}\\nStatus: ${data.status || 'N/A'}`;
							if (data.type === 'host') {
								info += `\\nIP: ${data.ip || 'N/A'}\\nCPU: ${data.cpu || 'N/A'}\\nMemory: ${data.memory ? (data.memory / 1024 / 1024 / 1024).toFixed(1) + ' GB' : 'N/A'}`;
							} else if (data.type === 'container') {
								info += `\\nImage: ${data.image || 'N/A'}`;
							}
							showNodeInfoModal(data);
						});
					})
					.catch(error => {
						console.error('Failed to load graph data:', error);
						document.getElementById('cy').innerHTML = '<div class="graph-loading">Failed to load graph data</div>';
					});
			}

			// Layout selector
			document.getElementById('layout-select').addEventListener('change', function(e) {
				if (cy) {
					cy.layout({
						name: e.target.value,
						animate: true,
						animationDuration: 500,
						fit: true,
						padding: 50
					}).run();
				}
			});

			// Control buttons
			document.getElementById('btn-fit').addEventListener('click', function() {
				if (cy) cy.fit();
			});

			document.getElementById('btn-center').addEventListener('click', function() {
				if (cy) cy.center();
			});

			document.getElementById('btn-refresh').addEventListener('click', function() {
				const layout = document.getElementById('layout-select').value;
				initGraph(layout);
			});

			// Export button handlers
			document.getElementById('btn-export-png').addEventListener('click', function() {
				if (!cy) return;
				const png = cy.png({ full: true, scale: 2 });
				downloadFile(png, 'graphium-graph.png');
				showNotification('Graph exported as PNG', 'success');
			});

			document.getElementById('btn-export-svg').addEventListener('click', function() {
				if (!cy) return;
				const svg = cy.svg({ full: true, scale: 1 });
				const blob = new Blob([svg], { type: 'image/svg+xml' });
				const url = URL.createObjectURL(blob);
				downloadFile(url, 'graphium-graph.svg');
				URL.revokeObjectURL(url);
				showNotification('Graph exported as SVG', 'success');
			});

			document.getElementById('btn-export-json').addEventListener('click', function() {
				if (!cy) return;
				const graphData = {
					nodes: cy.nodes().map(node => node.json()),
					edges: cy.edges().map(edge => edge.json())
				};
				const json = JSON.stringify(graphData, null, 2);
				const blob = new Blob([json], { type: 'application/json' });
				const url = URL.createObjectURL(blob);
				downloadFile(url, 'graphium-graph.json');
				URL.revokeObjectURL(url);
				showNotification('Graph exported as JSON', 'success');
			});

			// Helper function to download files
			function downloadFile(url, filename) {
				const link = document.createElement('a');
				link.href = url;
				link.download = filename;
				document.body.appendChild(link);
				link.click();
				document.body.removeChild(link);
			}

			// Populate datacenter filter with unique datacenters from nodes
			function populateDatacenterFilter(nodes) {
				const datacenters = new Set();
				nodes.forEach(node => {
					if (node.data && node.data.datacenter) {
						datacenters.add(node.data.datacenter);
					}
				});

				const select = document.getElementById('filter-datacenter');
				// Keep the "All Datacenters" option
				select.innerHTML = '<option value="all">All Datacenters</option>';

				// Add unique datacenters
				Array.from(datacenters).sort().forEach(dc => {
					const option = document.createElement('option');
					option.value = dc;
					option.textContent = dc;
					select.appendChild(option);
				});
			}

			// Apply filters to graph data
			function applyFilters(data, filters) {
				let filteredNodes = data.nodes.filter(node => {
					const nodeData = node.data;

					// Filter by type
					if (filters.type !== 'all' && nodeData.type !== filters.type) {
						return false;
					}

					// Filter by status
					if (filters.status !== 'all' && nodeData.status !== filters.status) {
						return false;
					}

					// Filter by datacenter (for hosts and containers)
					if (filters.datacenter !== 'all' && nodeData.datacenter !== filters.datacenter) {
						return false;
					}

					return true;
				});

				// Get IDs of filtered nodes
				const nodeIds = new Set(filteredNodes.map(n => n.data.id));

				// Filter edges to only include those connecting visible nodes
				const filteredEdges = data.edges.filter(edge => {
					const source = edge.data.source;
					const target = edge.data.target;
					return nodeIds.has(source) && nodeIds.has(target);
				});

				return {
					nodes: filteredNodes,
					edges: filteredEdges
				};
			}

			// Reapply filters and redraw graph
			function reapplyFilters() {
				const layout = document.getElementById('layout-select').value;
				const filteredData = applyFilters(originalData, currentFilters);

				// Update stats
				const stats = {
					nodes: filteredData.nodes.length,
					hosts: filteredData.nodes.filter(n => n.data.type === 'host').length,
					containers: filteredData.nodes.filter(n => n.data.type === 'container').length,
					edges: filteredData.edges.length
				};

				document.getElementById('stat-nodes').textContent = stats.nodes;
				document.getElementById('stat-hosts').textContent = stats.hosts;
				document.getElementById('stat-containers').textContent = stats.containers;
				document.getElementById('stat-edges').textContent = stats.edges;

				// Recreate graph with filtered data
				if (cy) {
					cy.destroy();
				}

				cy = cytoscape({
					container: document.getElementById('cy'),
					elements: filteredData,
					style: [
						{
							selector: 'node',
							style: {
								'background-color': '#6366f1',
								'label': 'data(label)',
								'color': '#f1f5f9',
								'text-valign': 'center',
								'text-halign': 'center',
								'font-size': '12px',
								'width': 60,
								'height': 60,
								'border-width': 2,
								'border-color': '#8b5cf6'
							}
						},
						{
							selector: 'node[type="host"]',
							style: {
								'background-color': '#6366f1',
								'shape': 'rectangle',
								'width': 80,
								'height': 60,
								'border-color': '#4f46e5'
							}
						},
						{
							selector: 'node[type="container"]',
							style: {
								'background-color': '#10b981',
								'shape': 'ellipse',
								'width': 60,
								'height': 60
							}
						},
						{
							selector: 'node[status="stopped"]',
							style: {
								'background-color': '#94a3b8',
								'opacity': 0.7
							}
						},
						{
							selector: 'node[status="running"]',
							style: {
								'background-color': '#10b981'
							}
						},
						{
							selector: 'edge',
							style: {
								'width': 2,
								'line-color': '#475569',
								'target-arrow-color': '#475569',
								'target-arrow-shape': 'triangle',
								'curve-style': 'bezier',
								'arrow-scale': 1.5
							}
						},
						{
							selector: 'node:selected',
							style: {
								'border-width': 4,
								'border-color': '#f59e0b'
							}
						}
					],
					layout: {
						name: layout,
						animate: true,
						animationDuration: 500,
						fit: true,
						padding: 50,
						randomize: false,
						componentSpacing: 100,
						nodeRepulsion: 400000,
						idealEdgeLength: 100,
						edgeElasticity: 100
					}
				});

				// Re-add node click handlers for modal
				cy.on('tap', 'node', function(evt) {
					const node = evt.target;
					const data = node.data();
					showNodeInfoModal(data);
				});
			}

			// Filter event listeners
			document.getElementById('filter-type').addEventListener('change', function(e) {
				currentFilters.type = e.target.value;
				reapplyFilters();
			});

			document.getElementById('filter-status').addEventListener('change', function(e) {
				currentFilters.status = e.target.value;
				reapplyFilters();
			});

			document.getElementById('filter-datacenter').addEventListener('change', function(e) {
				currentFilters.datacenter = e.target.value;
				reapplyFilters();
			});

			document.getElementById('btn-clear-filters').addEventListener('click', function() {
				currentFilters = { type: 'all', status: 'all', datacenter: 'all' };
				document.getElementById('filter-type').value = 'all';
				document.getElementById('filter-status').value = 'all';
				document.getElementById('filter-datacenter').value = 'all';
				reapplyFilters();
			});

			// WebSocket connection for real-time updates
			let ws = null;
			let wsReconnectAttempts = 0;
			const maxReconnectAttempts = 10;
			const reconnectDelay = 3000;

			function connectWebSocket() {
				const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
				const wsURL = `${protocol}//${window.location.host}/api/v1/ws/graph`;

				try {
					ws = new WebSocket(wsURL);

					ws.onopen = function() {
						console.log('WebSocket connected');
						wsReconnectAttempts = 0;
						// Add connection indicator
						const indicator = document.createElement('div');
						indicator.id = 'ws-status';
						indicator.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background: #10b981; color: white; padding: 8px 16px; border-radius: 4px; font-size: 14px; z-index: 1000;';
						indicator.textContent = '‚óè Connected';
						document.body.appendChild(indicator);
						setTimeout(() => indicator.remove(), 3000);
					};

					ws.onmessage = function(event) {
						try {
							const graphEvent = JSON.parse(event.data);
							console.log('WebSocket event received:', graphEvent);
							handleGraphEvent(graphEvent);
						} catch (error) {
							console.error('Failed to parse WebSocket message:', error);
						}
					};

					ws.onerror = function(error) {
						console.error('WebSocket error:', error);
					};

					ws.onclose = function() {
						console.log('WebSocket disconnected');
						// Remove connection indicator if exists
						const indicator = document.getElementById('ws-status');
						if (indicator) indicator.remove();

						// Attempt reconnection
						if (wsReconnectAttempts < maxReconnectAttempts) {
							wsReconnectAttempts++;
							console.log(`Reconnecting WebSocket (attempt ${wsReconnectAttempts}/${maxReconnectAttempts})...`);
							setTimeout(connectWebSocket, reconnectDelay);
						} else {
							console.error('Max WebSocket reconnection attempts reached');
						}
					};
				} catch (error) {
					console.error('Failed to create WebSocket connection:', error);
				}
			}

			function handleGraphEvent(event) {
				if (!cy) return;

				switch (event.type) {
					case 'container_added':
						handleContainerAdded(event.data);
						break;
					case 'container_updated':
						handleContainerUpdated(event.data);
						break;
					case 'container_removed':
						handleContainerRemoved(event.data);
						break;
					case 'host_added':
						handleHostAdded(event.data);
						break;
					case 'host_updated':
						handleHostUpdated(event.data);
						break;
					case 'host_removed':
						handleHostRemoved(event.data);
						break;
					case 'graph_refresh':
						// Refresh the entire graph
						const layout = document.getElementById('layout-select').value;
						initGraph(layout);
						break;
					default:
						console.warn('Unknown event type:', event.type);
				}

				// Update stats after any change
				updateStats();
			}

			function handleContainerAdded(container) {
				const nodeId = container['@id'] || container.id;

				// Check if node already exists
				if (cy.$('#' + nodeId).length > 0) {
					return;
				}

				// Add container node
				cy.add({
					data: {
						id: nodeId,
						label: container.name,
						type: 'container',
						status: container.status,
						image: container.image
					}
				});

				// Add edge to host if hostedOn exists
				if (container.hostedOn) {
					const hostId = container.hostedOn['@id'] || container.hostedOn;
					if (cy.$('#' + hostId).length > 0) {
						cy.add({
							data: {
								id: 'edge-' + nodeId,
								source: hostId,
								target: nodeId
							}
						});
					}
				}

				// Animate the new node
				cy.$('#' + nodeId).animate({
					style: { opacity: 1 }
				}, {
					duration: 500
				});

				// Re-layout the graph
				cy.layout({
					name: document.getElementById('layout-select').value,
					animate: true,
					animationDuration: 500,
					fit: false
				}).run();

				showNotification('Container added: ' + container.name, 'success');
			}

			function handleContainerUpdated(container) {
				const nodeId = container['@id'] || container.id;
				const node = cy.$('#' + nodeId);

				if (node.length > 0) {
					// Update node data
					node.data({
						label: container.name,
						status: container.status,
						image: container.image
					});

					// Flash animation
					node.animate({
						style: { 'border-width': '4px' }
					}, {
						duration: 300,
						complete: function() {
							node.animate({
								style: { 'border-width': '2px' }
							}, {
								duration: 300
							});
						}
					});

					showNotification('Container updated: ' + container.name, 'info');
				}
			}

			function handleContainerRemoved(data) {
				const nodeId = data.id;
				const node = cy.$('#' + nodeId);

				if (node.length > 0) {
					// Fade out animation
					node.animate({
						style: { opacity: 0 }
					}, {
						duration: 500,
						complete: function() {
							// Remove node and connected edges
							node.remove();
							cy.$('#edge-' + nodeId).remove();
						}
					});

					showNotification('Container removed', 'warning');
				}
			}

			function handleHostAdded(host) {
				const nodeId = host['@id'] || host.id;

				// Check if node already exists
				if (cy.$('#' + nodeId).length > 0) {
					return;
				}

				// Add host node
				cy.add({
					data: {
						id: nodeId,
						label: host.name,
						type: 'host',
						status: host.status,
						ip: host.ipAddress,
						cpu: host.cpuCores,
						memory: host.memoryBytes
					}
				});

				// Animate the new node
				cy.$('#' + nodeId).animate({
					style: { opacity: 1 }
				}, {
					duration: 500
				});

				// Re-layout the graph
				cy.layout({
					name: document.getElementById('layout-select').value,
					animate: true,
					animationDuration: 500,
					fit: false
				}).run();

				showNotification('Host added: ' + host.name, 'success');
			}

			function handleHostUpdated(host) {
				const nodeId = host['@id'] || host.id;
				const node = cy.$('#' + nodeId);

				if (node.length > 0) {
					// Update node data
					node.data({
						label: host.name,
						status: host.status,
						ip: host.ipAddress,
						cpu: host.cpuCores,
						memory: host.memoryBytes
					});

					// Flash animation
					node.animate({
						style: { 'border-width': '6px' }
					}, {
						duration: 300,
						complete: function() {
							node.animate({
								style: { 'border-width': '3px' }
							}, {
								duration: 300
							});
						}
					});

					showNotification('Host updated: ' + host.name, 'info');
				}
			}

			function handleHostRemoved(data) {
				const nodeId = data.id;
				const node = cy.$('#' + nodeId);

				if (node.length > 0) {
					// Get all containers connected to this host
					const connectedContainers = cy.$('#' + nodeId).neighborhood('node[type="container"]');

					// Fade out animation for host and containers
					node.add(connectedContainers).animate({
						style: { opacity: 0 }
					}, {
						duration: 500,
						complete: function() {
							// Remove host, containers, and edges
							node.add(connectedContainers).remove();
						}
					});

					showNotification('Host removed', 'warning');
				}
			}

			function updateStats() {
				if (!cy) return;

				const hosts = cy.nodes('[type="host"]').length;
				const containers = cy.nodes('[type="container"]').length;
				const edges = cy.edges().length;
				const totalNodes = hosts + containers;

				const nodeCountEl = document.getElementById('stat-nodes');
				const hostCountEl = document.getElementById('stat-hosts');
				const containerCountEl = document.getElementById('stat-containers');
				const edgeCountEl = document.getElementById('stat-edges');

				if (nodeCountEl) nodeCountEl.textContent = totalNodes;
				if (hostCountEl) hostCountEl.textContent = hosts;
				if (containerCountEl) containerCountEl.textContent = containers;
				if (edgeCountEl) edgeCountEl.textContent = edges;
			}

			// Activity tracking system (replaces individual notifications)
			const activityLog = {
				items: [],
				maxItems: 100,
				counters: {},
				lastUpdate: Date.now(),
				batchTimeout: null,

				add: function(message, type = 'info') {
					// Update counter for batch aggregation
					const key = `${type}:${message}`;
					if (!this.counters[key]) {
						this.counters[key] = { count: 0, type: type, message: message, firstSeen: Date.now() };
					}
					this.counters[key].count++;
					this.counters[key].lastSeen = Date.now();

					// Schedule batch update
					clearTimeout(this.batchTimeout);
					this.batchTimeout = setTimeout(() => this.flushBatch(), 2000);
				},

				flushBatch: function() {
					// Convert counters to log items
					for (const key in this.counters) {
						const counter = this.counters[key];
						const displayMessage = counter.count > 1
							? `${counter.message} (${counter.count}x)`
							: counter.message;

						this.items.unshift({
							message: displayMessage,
							type: counter.type,
							timestamp: counter.lastSeen,
							count: counter.count
						});
					}

					// Clear counters
					this.counters = {};

					// Keep only last maxItems
					if (this.items.length > this.maxItems) {
						this.items = this.items.slice(0, this.maxItems);
					}

					this.render();
					this.showBadge();
				},

				render: function() {
					const container = document.getElementById('activityList');
					if (!container) return;

					const html = this.items.map(item => {
						const time = new Date(item.timestamp).toLocaleTimeString();
						const icon = {
							success: '‚úì',
							info: '‚Ñπ',
							warning: '‚ö†',
							error: '‚úó'
						}[item.type] || '‚Ñπ';

						return `
							<div class="activity-item activity-${item.type}">
								<span class="activity-icon">${icon}</span>
								<span class="activity-message">${item.message}</span>
								<span class="activity-time">${time}</span>
							</div>
						`;
					}).join('');

					container.innerHTML = html || '<div class="activity-empty">No recent activity</div>';
				},

				showBadge: function() {
					const badge = document.getElementById('activityBadge');
					const totalCount = this.items.reduce((sum, item) => sum + (item.count || 1), 0);

					if (totalCount > 0) {
						badge.textContent = totalCount > 99 ? '99+' : totalCount;
						badge.style.display = 'flex';
					}
				},

				clearBadge: function() {
					const badge = document.getElementById('activityBadge');
					badge.style.display = 'none';
				}
			};

			function showNotification(message, type = 'info') {
				activityLog.add(message, type);
			}

			// Activity panel toggle functions
			window.toggleActivityPanel = function() {
				const panel = document.getElementById('activityPanel');
				const isOpen = panel.classList.contains('open');

				if (isOpen) {
					panel.classList.remove('open');
				} else {
					panel.classList.add('open');
					activityLog.clearBadge();
					activityLog.render();
				}
			};

			window.clearActivityLog = function() {
				activityLog.items = [];
				activityLog.counters = [];
				activityLog.render();
				activityLog.clearBadge();
			};

			// Node info modal functions (exposed globally for onclick handlers)
			window.showNodeInfoModal = function(data) {
				const modal = document.getElementById('nodeInfoModal');
				const title = document.getElementById('nodeInfoTitle');
				const typeEl = document.getElementById('nodeInfoType');
				const content = document.getElementById('nodeInfoContent');

				// Set title based on type
				const icon = data.type === 'host' ? 'üñ•Ô∏è' : 'üì¶';
				title.textContent = icon + ' ' + (data.label || data.id);

				// Set type badge
				typeEl.textContent = data.type.toUpperCase();
				typeEl.className = 'node-info-type ' + (data.type === 'host' ? 'type-host' : 'type-container');

				// Build content based on type
				let html = '';
				html += '<div class="node-info-row"><span class="node-info-label">ID:</span><span class="node-info-value">' + (data.id || 'N/A') + '</span></div>';
				html += '<div class="node-info-row"><span class="node-info-label">Status:</span><span class="node-info-value"><span class="badge badge-' + (data.status || 'unknown') + '">' + (data.status || 'N/A').toUpperCase() + '</span></span></div>';

				if (data.type === 'host') {
					html += '<div class="node-info-row"><span class="node-info-label">IP Address:</span><span class="node-info-value">' + (data.ip || 'N/A') + '</span></div>';
					html += '<div class="node-info-row"><span class="node-info-label">CPU:</span><span class="node-info-value">' + (data.cpu || 'N/A') + '</span></div>';
					if (data.memory) {
						const memoryGB = (data.memory / 1024 / 1024 / 1024).toFixed(1);
						html += '<div class="node-info-row"><span class="node-info-label">Memory:</span><span class="node-info-value">' + memoryGB + ' GB</span></div>';
					} else {
						html += '<div class="node-info-row"><span class="node-info-label">Memory:</span><span class="node-info-value">N/A</span></div>';
					}
					if (data.datacenter) {
						html += '<div class="node-info-row"><span class="node-info-label">Datacenter:</span><span class="node-info-value">' + data.datacenter + '</span></div>';
					}
				} else if (data.type === 'container') {
					html += '<div class="node-info-row"><span class="node-info-label">Image:</span><span class="node-info-value">' + (data.image || 'N/A') + '</span></div>';
					if (data.command) {
						html += '<div class="node-info-row"><span class="node-info-label">Command:</span><span class="node-info-value" style="font-family: monospace; font-size: 0.85rem;">' + data.command + '</span></div>';
					}
				}

				content.innerHTML = html;
				modal.style.display = 'flex';
			};

			window.closeNodeInfoModal = function() {
				const modal = document.getElementById('nodeInfoModal');
				modal.style.display = 'none';
			};

			// Close modal when clicking outside (on the backdrop)
			window.addEventListener('click', function(event) {
				const modal = document.getElementById('nodeInfoModal');
				if (event.target === modal) {
					closeNodeInfoModal();
				}
			});

			// Close modal on Escape key
			document.addEventListener('keydown', function(event) {
				if (event.key === 'Escape') {
					closeNodeInfoModal();
				}
			});

			// Initialize graph on page load
			initGraph();

			// Connect WebSocket after graph is initialized
			setTimeout(connectWebSocket, 1000);
		})();
		</script>

		<!-- Activity Panel -->
		<div id="activityPanel" class="activity-panel">
			<div class="activity-header">
				<h3>Activity Log</h3>
				<div class="activity-header-actions">
					<button type="button" class="btn-icon" onclick="clearActivityLog()" title="Clear all">‚úï</button>
					<button type="button" class="btn-icon" onclick="toggleActivityPanel()" title="Close">‚ñº</button>
				</div>
			</div>
			<div class="activity-body">
				<div id="activityList"></div>
			</div>
		</div>

		<!-- Activity Toggle Button -->
		<button id="activityToggle" class="activity-toggle" onclick="toggleActivityPanel()">
			<span class="activity-icon">üìä</span>
			<span class="activity-label">Activity</span>
			<span id="activityBadge" class="activity-badge">0</span>
		</button>

		<!-- Node Info Modal -->
		<div id="nodeInfoModal" class="modal">
			<div class="modal-content">
				<div class="modal-header">
					<h3 id="nodeInfoTitle">Node Information</h3>
					<span class="node-info-type" id="nodeInfoType">NODE</span>
				</div>
				<div class="modal-body">
					<div id="nodeInfoContent"></div>
				</div>
				<div class="modal-footer">
					<button type="button" class="btn btn-secondary" onclick="closeNodeInfoModal()">Close</button>
				</div>
			</div>
		</div>
	}
}

// Container detail view template (with user)
templ ContainerDetailWithUser(container *models.Container, host *models.Host, stack *models.Stack, belongsToStack bool, user *models.User) {
	@LayoutWithUser("Container Details", user) {
		<div class="page-header">
			<div>
				<h2>Container Details</h2>
			</div>
			<div class="action-buttons">
				<a href="/web/containers" class="btn btn-secondary">‚Üê Back to Containers</a>
				if belongsToStack && stack != nil {
					<div class="alert alert-info" style="margin: 0; padding: 8px 12px; display: inline-block;">
						üì¶ Part of stack: <a href={ templ.URL(fmt.Sprintf("/web/stacks/%s", stack.ID)) } style="color: inherit; font-weight: bold;">{ stack.Name }</a>
					</div>
				} else {
					<form method="POST" action={ templ.URL(fmt.Sprintf("/web/containers/%s/delete", container.ID)) } id="delete-container-form" style="display: inline;">
						<button type="button" class="btn btn-danger" data-container-name={ container.Name } onclick="showConfirmModal('Delete Container', 'Are you sure you want to delete container &quot;' + this.dataset.containerName + '&quot;? This action cannot be undone.', 'Delete', function() { document.getElementById('delete-container-form').submit(); })">üóëÔ∏è Delete Container</button>
					</form>
				}
			</div>
		</div>

		<div class="detail-container">
			<div class="detail-section">
				<h3>Basic Information</h3>
				<div class="detail-grid">
					<div class="detail-item">
						<span class="detail-label">Name:</span>
						<span class="detail-value"><strong>{ container.Name }</strong></span>
					</div>
					<div class="detail-item">
						<span class="detail-label">ID:</span>
						<span class="detail-value">{ container.ID }</span>
					</div>
					<div class="detail-item">
						<span class="detail-label">Status:</span>
						<span class={ fmt.Sprintf("badge badge-%s", container.Status) }>
							{ container.Status }
						</span>
					</div>
					<div class="detail-item">
						<span class="detail-label">Image:</span>
						<span class="detail-value">{ container.Image }</span>
					</div>
				</div>
			</div>

			if host != nil {
				<div class="detail-section">
					<h3>Host Information</h3>
					<div class="detail-grid">
						<div class="detail-item">
							<span class="detail-label">Host Name:</span>
							<span class="detail-value">
								<a href={ templ.URL(fmt.Sprintf("/web/hosts/%s", host.ID)) }>{ host.Name }</a>
							</span>
						</div>
						<div class="detail-item">
							<span class="detail-label">Host IP:</span>
							<span class="detail-value">{ host.IPAddress }</span>
						</div>
						<div class="detail-item">
							<span class="detail-label">Datacenter:</span>
							<span class="detail-value">{ host.Datacenter }</span>
						</div>
					</div>
				</div>
			}

			if len(container.Ports) > 0 {
				<div class="detail-section">
					<h3>Network Ports</h3>
					<div class="table-container">
						<table class="data-table">
							<thead>
								<tr>
									<th>Host Port</th>
									<th>Container Port</th>
									<th>Protocol</th>
								</tr>
							</thead>
							<tbody>
								for _, port := range container.Ports {
									<tr>
										<td>{ fmt.Sprintf("%d", port.HostPort) }</td>
										<td>{ fmt.Sprintf("%d", port.ContainerPort) }</td>
										<td>{ port.Protocol }</td>
									</tr>
								}
							</tbody>
						</table>
					</div>
				</div>
			}

			if len(container.Env) > 0 {
				<div class="detail-section">
					<h3>Environment Variables</h3>
					<div class="table-container">
						<table class="data-table">
							<thead>
								<tr>
									<th>Variable</th>
									<th>Value</th>
								</tr>
							</thead>
							<tbody>
								for key, value := range container.Env {
									<tr>
										<td><code>{ key }</code></td>
										<td><code>{ value }</code></td>
									</tr>
								}
							</tbody>
						</table>
					</div>
				</div>
			}

			if container.Created != "" {
				<div class="detail-section">
					<h3>Timestamps</h3>
					<div class="detail-grid">
						<div class="detail-item">
							<span class="detail-label">Created:</span>
							<span class="detail-value">{ container.Created }</span>
						</div>
					</div>
				</div>
			}

			<div class="detail-section">
				<h3>JSON-LD Metadata</h3>
				<div class="detail-grid">
					<div class="detail-item">
						<span class="detail-label">Context:</span>
						<span class="detail-value">{ container.Context }</span>
					</div>
					<div class="detail-item">
						<span class="detail-label">Type:</span>
						<span class="detail-value">{ container.Type }</span>
					</div>
					<div class="detail-item">
						<span class="detail-label">ID:</span>
						<span class="detail-value"><small>{ container.ID }</small></span>
					</div>
				</div>
			</div>
		</div>
	}
}

// Host detail view template (with user)
templ HostDetailWithUser(host *models.Host, containers []*models.Container, user *models.User) {
	@LayoutWithUser("Host Details", user) {
		<div class="page-header">
			<div>
				<h2>Host Details</h2>
			</div>
			<div class="action-buttons">
				<a href="/web/hosts" class="btn btn-secondary">‚Üê Back to Hosts</a>
				<a href={ templ.URL(fmt.Sprintf("/web/hosts/%s/edit", host.ID)) } class="btn btn-primary">‚úèÔ∏è Edit Host</a>
				<form method="POST" action={ templ.URL(fmt.Sprintf("/web/hosts/%s/delete", host.ID)) } id="delete-host-form" style="display: inline;">
					<button type="button" class="btn btn-danger" data-host-name={ host.Name } onclick="showConfirmModal('Delete Host', 'Are you sure you want to delete host &quot;' + this.dataset.hostName + '&quot;? This action cannot be undone.', 'Delete', function() { document.getElementById('delete-host-form').submit(); })">üóëÔ∏è Delete Host</button>
				</form>
			</div>
		</div>

		<div class="detail-container">
			<div class="detail-section">
				<h3>Basic Information</h3>
				<div class="detail-grid">
					<div class="detail-item">
						<span class="detail-label">Name:</span>
						<span class="detail-value"><strong>{ host.Name }</strong></span>
					</div>
					<div class="detail-item">
						<span class="detail-label">ID:</span>
						<span class="detail-value">{ host.ID }</span>
					</div>
					<div class="detail-item">
						<span class="detail-label">Status:</span>
						<span class={ fmt.Sprintf("badge badge-%s", host.Status) }>
							{ host.Status }
						</span>
					</div>
					<div class="detail-item">
						<span class="detail-label">IP Address:</span>
						<span class="detail-value">{ host.IPAddress }</span>
					</div>
					<div class="detail-item">
						<span class="detail-label">Datacenter:</span>
						<span class="detail-value">{ host.Datacenter }</span>
					</div>
				</div>
			</div>

			<div class="detail-section">
				<h3>Hardware Resources</h3>
				<div class="detail-grid">
					<div class="detail-item">
						<span class="detail-label">CPU Cores:</span>
						<span class="detail-value">{ fmt.Sprintf("%d cores", host.CPU) }</span>
					</div>
					<div class="detail-item">
						<span class="detail-label">Memory:</span>
						<span class="detail-value">{ fmt.Sprintf("%.2f GB", float64(host.Memory) / 1024 / 1024 / 1024) }</span>
					</div>
				</div>
			</div>

			<div class="detail-section">
				<h3>Containers ({ fmt.Sprintf("%d", len(containers)) })</h3>
				if len(containers) > 0 {
					<div class="table-container">
						<table class="data-table">
							<thead>
								<tr>
									<th>Name</th>
									<th>Image</th>
									<th>Status</th>
									<th>Actions</th>
								</tr>
							</thead>
							<tbody>
								for _, container := range containers {
									<tr>
										<td>
											<strong>{ container.Name }</strong>
											<br/>
											<small class="text-muted">{ container.ID }</small>
										</td>
										<td>{ container.Image }</td>
										<td>
											<span class={ fmt.Sprintf("badge badge-%s", container.Status) }>
												{ container.Status }
											</span>
										</td>
										<td>
											<a href={ templ.URL(fmt.Sprintf("/web/containers/%s", container.ID)) } class="btn-icon" title="View Details">üëÅÔ∏è</a>
										</td>
									</tr>
								}
							</tbody>
						</table>
					</div>
				} else {
					<p class="no-data">No containers running on this host</p>
				}
			</div>

			<div class="detail-section">
				<h3>JSON-LD Metadata</h3>
				<div class="detail-grid">
					<div class="detail-item">
						<span class="detail-label">Context:</span>
						<span class="detail-value">{ host.Context }</span>
					</div>
					<div class="detail-item">
						<span class="detail-label">Type:</span>
						<span class="detail-value">{ host.Type }</span>
					</div>
					<div class="detail-item">
						<span class="detail-label">ID:</span>
						<span class="detail-value"><small>{ host.ID }</small></span>
					</div>
				</div>
			</div>
		</div>
	}
}

// Login page template
templ LoginPage(errorMsg string) {
	<!DOCTYPE html>
	<html lang="en">
	<head>
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
		<title>Login - Graphium</title>
		<link rel="stylesheet" href="/static/css/styles.css"/>
	</head>
	<body>
		<div class="login-container">
			<div class="login-box">
				<div class="login-header">
					<h1>üß¨ Graphium</h1>
					<p>Container Intelligence Platform</p>
				</div>

				if errorMsg != "" {
					<div class="alert alert-error">
						{ errorMsg }
					</div>
				}

				<form method="POST" action="/web/auth/login" class="login-form">
					<div class="form-group">
						<label for="username">Username</label>
						<input type="text" id="username" name="username" required autocomplete="username"/>
					</div>

					<div class="form-group">
						<label for="password">Password</label>
						<input type="password" id="password" name="password" required autocomplete="current-password"/>
					</div>

					<button type="submit" class="btn btn-primary btn-block">Login</button>
				</form>
			</div>
		</div>
	</body>
	</html>
}

// User list page template for admin
templ UsersList(users []*models.User, currentUser *models.User) {
	@LayoutWithUser("User Management", currentUser) {
		<div class="page-header">
			<h2>User Management</h2>
			<div class="header-actions">
				<a href="/web/users/new" class="btn btn-primary">‚ûï Add User</a>
			</div>
		</div>

		<div class="table-container">
			<table class="data-table">
				<thead>
					<tr>
						<th>Username</th>
						<th>Email</th>
						<th>Name</th>
						<th>Roles</th>
						<th>Status</th>
						<th>Last Login</th>
						<th>Actions</th>
					</tr>
				</thead>
				<tbody>
					if len(users) == 0 {
						<tr>
							<td colspan="7" class="text-center text-muted">No users found</td>
						</tr>
					}
					for _, user := range users {
						<tr>
							<td><strong>{ user.Username }</strong></td>
							<td>{ user.Email }</td>
							<td>{ user.Name }</td>
							<td>
								<div class="roles-list">
									for _, role := range user.Roles {
										if role == models.RoleAdmin {
											<span class="badge badge-danger">{ string(role) }</span>
										} else if role == models.RoleUser {
											<span class="badge badge-success">{ string(role) }</span>
										} else if role == models.RoleViewer {
											<span class="badge badge-info">{ string(role) }</span>
										} else {
											<span class="badge badge-secondary">{ string(role) }</span>
										}
									}
								</div>
							</td>
							<td>
								if user.Enabled {
									<span class="status-badge status-running">Active</span>
								} else {
									<span class="status-badge status-stopped">Disabled</span>
								}
							</td>
							<td>
								if user.LastLoginAt != nil {
									<small>{ user.LastLoginAt.Format("2006-01-02 15:04") }</small>
								} else {
									<span class="text-muted">Never</span>
								}
							</td>
							<td class="actions">
								<a href={ templ.URL(fmt.Sprintf("/web/users/%s", user.ID)) } class="btn-icon" title="View Details">üëÅÔ∏è</a>
								if user.ID != currentUser.ID {
									<a href={ templ.URL(fmt.Sprintf("/web/users/%s/edit", user.ID)) } class="btn-icon" title="Edit User">‚úèÔ∏è</a>
									<button
										type="button"
										class="btn-icon"
										title="Delete User"
										onclick={ templ.ComponentScript{Call: fmt.Sprintf("showDeleteModal('%s', '%s')", user.ID, user.Username)} }
									>
										üóëÔ∏è
									</button>
								}
							</td>
						</tr>
					}
				</tbody>
			</table>
		</div>

		<!-- Delete User Confirmation Modal -->
		<div id="deleteModal" class="modal">
			<div class="modal-content">
				<div class="modal-header">
					<h3>‚ö†Ô∏è Confirm Deletion</h3>
				</div>
				<div class="modal-body">
					<p>Are you sure you want to delete user <strong id="deleteUsername"></strong>?</p>
					<p class="text-muted">This action cannot be undone.</p>
				</div>
				<div class="modal-footer">
					<button type="button" class="btn btn-secondary" onclick="closeDeleteModal()">Cancel</button>
					<form id="deleteForm" method="POST" style="display: inline;">
						<button type="submit" class="btn btn-danger">Delete User</button>
					</form>
				</div>
			</div>
		</div>

		<script>
			function showDeleteModal(userId, username) {
				const modal = document.getElementById('deleteModal');
				const usernameEl = document.getElementById('deleteUsername');
				const form = document.getElementById('deleteForm');

				usernameEl.textContent = username;
				form.action = '/web/users/' + userId + '/delete';
				modal.style.display = 'flex';
			}

			function closeDeleteModal() {
				const modal = document.getElementById('deleteModal');
				modal.style.display = 'none';
			}

			function showRevokeApiKeyModal(userId, username, apiKey) {
				const modal = document.getElementById('revokeApiKeyModal');
				const apiKeyEl = document.getElementById('revokeApiKey');
				const usernameEl = document.getElementById('revokeUsername');
				const form = document.getElementById('revokeApiKeyForm');

				// Truncate API key for display (show first 8 and last 4 chars)
				const displayKey = apiKey.length > 12 ?
					apiKey.substring(0, 8) + '...' + apiKey.substring(apiKey.length - 4) :
					apiKey;
				apiKeyEl.textContent = displayKey;
				usernameEl.textContent = username;
				form.action = '/web/users/' + userId + '/apikeys/' + encodeURIComponent(apiKey) + '/revoke';
				modal.style.display = 'flex';
			}

			function closeRevokeApiKeyModal() {
				const modal = document.getElementById('revokeApiKeyModal');
				modal.style.display = 'none';
			}

			// Close modal when clicking outside of it
			window.onclick = function(event) {
				const deleteModal = document.getElementById('deleteModal');
				const revokeModal = document.getElementById('revokeApiKeyModal');

				if (event.target == deleteModal) {
					closeDeleteModal();
				}
				if (event.target == revokeModal) {
					closeRevokeApiKeyModal();
				}
			}

			// Close modal on Escape key
			document.addEventListener('keydown', function(event) {
				if (event.key === 'Escape') {
					closeDeleteModal();
					closeRevokeApiKeyModal();
				}
			});
		</script>
	}
}

// User detail page template
templ UserDetail(user *models.User, currentUser *models.User, isAdmin bool) {
	@LayoutWithUser("User Details", currentUser) {
		<div class="page-header">
			<div>
				<a href="/web/users" class="btn btn-secondary">‚Üê Back to Users</a>
				<h2>User Details</h2>
			</div>
			<div class="header-actions">
				if user.ID == currentUser.ID || isAdmin {
					<a href={ templ.URL(fmt.Sprintf("/web/users/%s/edit", user.ID)) } class="btn btn-primary">‚úèÔ∏è Edit</a>
				}
			</div>
		</div>

		<div class="detail-container">
			<div class="detail-section">
				<h3>Account Information</h3>
				<div class="detail-grid">
					<div class="detail-item">
						<span class="detail-label">Username:</span>
						<span class="detail-value"><strong>{ user.Username }</strong></span>
					</div>
					<div class="detail-item">
						<span class="detail-label">Email:</span>
						<span class="detail-value">{ user.Email }</span>
					</div>
					<div class="detail-item">
						<span class="detail-label">Name:</span>
						<span class="detail-value">{ user.Name }</span>
					</div>
					<div class="detail-item">
						<span class="detail-label">Status:</span>
						if user.Enabled {
							<span class="status-badge status-running">Active</span>
						} else {
							<span class="status-badge status-stopped">Disabled</span>
						}
					</div>
				</div>
			</div>

			<div class="detail-section">
				<h3>Roles & Permissions</h3>
				<div class="roles-list">
					for _, role := range user.Roles {
						if role == models.RoleAdmin {
							<span class="badge badge-danger">{ string(role) }</span>
						} else if role == models.RoleUser {
							<span class="badge badge-success">{ string(role) }</span>
						} else if role == models.RoleViewer {
							<span class="badge badge-info">{ string(role) }</span>
						} else {
							<span class="badge badge-secondary">{ string(role) }</span>
						}
					}
				</div>
			</div>

			<div class="detail-section">
				<h3>Activity</h3>
				<div class="detail-grid">
					<div class="detail-item">
						<span class="detail-label">Created:</span>
						<span class="detail-value">{ user.CreatedAt.Format("2006-01-02 15:04:05") }</span>
					</div>
					<div class="detail-item">
						<span class="detail-label">Last Updated:</span>
						<span class="detail-value">{ user.UpdatedAt.Format("2006-01-02 15:04:05") }</span>
					</div>
					<div class="detail-item">
						<span class="detail-label">Last Login:</span>
						if user.LastLoginAt != nil {
							<span class="detail-value">{ user.LastLoginAt.Format("2006-01-02 15:04:05") }</span>
						} else {
							<span class="detail-value text-muted">Never</span>
						}
					</div>
				</div>
			</div>

			if user.ID == currentUser.ID {
				<div class="detail-section">
					<h3>API Keys</h3>
					if len(user.APIKeys) > 0 {
						<div class="api-keys-list">
							for i, key := range user.APIKeys {
								<div class="api-key-item">
									<code>{ key[:8] }...{ key[len(key)-8:] }</code>
									<form method="POST" action={ templ.URL(fmt.Sprintf("/web/users/%s/api-keys/%d/revoke", user.ID, i)) } style="display: inline;" onsubmit="return confirm('Are you sure you want to revoke this API key?');">
										<button type="submit" class="btn btn-sm btn-danger">Revoke</button>
									</form>
								</div>
							}
						</div>
					} else {
						<p class="text-muted">No API keys generated</p>
					}
					<form method="POST" action={ templ.URL(fmt.Sprintf("/web/users/%s/api-keys/generate", user.ID)) }>
						<button type="submit" class="btn btn-primary">üîë Generate New API Key</button>
					</form>
				</div>
			}

			<div class="detail-section">
				<h3>JSON-LD Metadata</h3>
				<div class="detail-grid">
					<div class="detail-item">
						<span class="detail-label">Context:</span>
						<span class="detail-value"><small>{ user.Context }</small></span>
					</div>
					<div class="detail-item">
						<span class="detail-label">Type:</span>
						<span class="detail-value">{ user.Type }</span>
					</div>
					<div class="detail-item">
						<span class="detail-label">ID:</span>
						<span class="detail-value"><small>{ user.ID }</small></span>
					</div>
				</div>
			</div>
		</div>
	}
}

// User create form template
templ UserFormCreate(user *models.User, currentUser *models.User, errorMsg string) {
	@LayoutWithUser("Create User", currentUser) {
		@userFormContent(user, true, errorMsg)
	}
}

// User edit form template
templ UserFormEdit(user *models.User, currentUser *models.User, errorMsg string) {
	@LayoutWithUser("Edit User", currentUser) {
		@userFormContent(user, false, errorMsg)
	}
}

// User form content (shared between create and edit)
templ userFormContent(user *models.User, isNew bool, errorMsg string) {
		<div class="page-header">
			<div>
				<a href="/web/users" class="btn btn-secondary">‚Üê Back to Users</a>
				<h2>
					if isNew {
						Create New User
					} else {
						Edit User
					}
				</h2>
			</div>
		</div>

		if errorMsg != "" {
			<div class="alert alert-error">
				{ errorMsg }
			</div>
		}

		<div class="form-container">
			if isNew {
				<form method="POST" action="/web/users/create" class="user-form">
					@userFormFields(user, isNew)
				</form>
			} else {
				<form method="POST" action={ templ.URL(fmt.Sprintf("/web/users/%s/update", user.ID)) } class="user-form">
					@userFormFields(user, isNew)
				</form>
			}
		</div>
}

// User form fields (shared between create and edit forms)
templ userFormFields(user *models.User, isNew bool) {
				<div class="form-section">
					<h3>Account Information</h3>

					<div class="form-group">
						<label for="username">Username *</label>
						<input type="text" id="username" name="username" value={ user.Username } required disabled?={ !isNew }/>
						if !isNew {
							<small class="form-text">Username cannot be changed</small>
						}
					</div>

					<div class="form-group">
						<label for="email">Email</label>
						<input type="email" id="email" name="email" value={ user.Email }/>
					</div>

					<div class="form-group">
						<label for="name">Full Name</label>
						<input type="text" id="name" name="name" value={ user.Name }/>
					</div>

					if isNew {
						<div class="form-group">
							<label for="password">Password *</label>
							<input type="password" id="password" name="password" required minlength="8"/>
							<small class="form-text">Minimum 8 characters</small>
						</div>
					}
				</div>

				<div class="form-section">
					<h3>Roles & Permissions</h3>

					<div class="form-group">
						<label class="checkbox-label">
							<input type="checkbox" name="roles" value="admin" checked?={ user.HasRole(models.RoleAdmin) }/>
							<span>Administrator - Full system access</span>
						</label>
					</div>

					<div class="form-group">
						<label class="checkbox-label">
							<input type="checkbox" name="roles" value="user" checked?={ user.HasRole(models.RoleUser) }/>
							<span>User - Read/write access to containers and hosts</span>
						</label>
					</div>

					<div class="form-group">
						<label class="checkbox-label">
							<input type="checkbox" name="roles" value="viewer" checked?={ user.HasRole(models.RoleViewer) }/>
							<span>Viewer - Read-only access</span>
						</label>
					</div>
				</div>

				<div class="form-section">
					<h3>Status</h3>

					<div class="form-group">
						<label class="checkbox-label">
							<input type="checkbox" name="enabled" checked?={ user.Enabled }/>
							<span>Account Enabled</span>
						</label>
					</div>
				</div>

				<div class="form-actions">
					<button type="submit" class="btn btn-primary">
						if isNew {
							Create User
						} else {
							Update User
						}
					</button>
					<a href="/web/users" class="btn btn-secondary">Cancel</a>
				</div>
}

// Profile/Settings page for current user
templ ProfilePage(user *models.User, errorMsg string, success string) {
	@LayoutWithUser("My Profile", user) {
		<div class="page-header">
			<h2>My Profile</h2>
		</div>

		if errorMsg != "" {
			<div class="alert alert-error">
				{ errorMsg }
			</div>
		}

		if success != "" {
			<div class="alert alert-success">
				{ success }
			</div>
		}

		<div class="detail-container">
			<div class="detail-section">
				<h3>Account Information</h3>
				<div class="detail-grid">
					<div class="detail-item">
						<span class="detail-label">Username:</span>
						<span class="detail-value"><strong>{ user.Username }</strong></span>
					</div>
					<div class="detail-item">
						<span class="detail-label">Email:</span>
						<span class="detail-value">{ user.Email }</span>
					</div>
					<div class="detail-item">
						<span class="detail-label">Name:</span>
						<span class="detail-value">{ user.Name }</span>
					</div>
					<div class="detail-item">
						<span class="detail-label">Roles:</span>
						<span class="detail-value">
							<div class="roles-list">
								for _, role := range user.Roles {
									if role == models.RoleAdmin {
										<span class="badge badge-danger">{ string(role) }</span>
									} else if role == models.RoleUser {
										<span class="badge badge-success">{ string(role) }</span>
									} else if role == models.RoleViewer {
										<span class="badge badge-info">{ string(role) }</span>
									} else {
										<span class="badge badge-secondary">{ string(role) }</span>
									}
								}
							</div>
						</span>
					</div>
				</div>
			</div>

			<div class="detail-section">
				<h3>Change Password</h3>
				<form method="POST" action="/web/profile/password" class="password-form">
					<div class="form-group">
						<label for="current_password">Current Password</label>
						<input type="password" id="current_password" name="current_password" required/>
					</div>

					<div class="form-group">
						<label for="new_password">New Password</label>
						<input type="password" id="new_password" name="new_password" required minlength="8"/>
						<small class="form-text">Minimum 8 characters</small>
					</div>

					<div class="form-group">
						<label for="confirm_password">Confirm New Password</label>
						<input type="password" id="confirm_password" name="confirm_password" required minlength="8"/>
					</div>

					<button type="submit" class="btn btn-primary">Change Password</button>
				</form>
			</div>
		</div>
	}
}

// Container Logs view template
templ ContainerLogsView(container *models.Container, host *models.Host, user *models.User) {
	@LayoutWithUser("Container Logs", user) {
		<div class="page-header">
			<div>
				<a href={ templ.URL(fmt.Sprintf("/web/containers/%s", container.ID)) } class="btn btn-secondary">‚Üê Back to Container</a>
				<h2>Container Logs: { container.Name }</h2>
			</div>
		</div>

		<div class="detail-container">
			<div class="detail-section">
				<div class="detail-grid" style="margin-bottom: 1rem;">
					<div class="detail-item">
						<span class="detail-label">Container:</span>
						<span class="detail-value"><strong>{ container.Name }</strong></span>
					</div>
					<div class="detail-item">
						<span class="detail-label">Status:</span>
						<span class={ fmt.Sprintf("badge badge-%s", container.Status) }>
							{ container.Status }
						</span>
					</div>
					if host != nil {
						<div class="detail-item">
							<span class="detail-label">Host:</span>
							<span class="detail-value">
								<a href={ templ.URL(fmt.Sprintf("/web/hosts/%s", host.ID)) }>{ host.Name }</a>
							</span>
						</div>
					}
				</div>

				<div style="margin-bottom: 1rem; display: flex; gap: 1rem; align-items: center;">
					<label style="display: flex; align-items: center; gap: 0.5rem;">
						<input type="checkbox" id="auto-refresh" checked/>
						<span>Auto-refresh (5s)</span>
					</label>
					<label style="display: flex; align-items: center; gap: 0.5rem;">
						<span>Lines:</span>
						<select id="lines-select" style="padding: 0.25rem;">
							<option value="100">100</option>
							<option value="500">500</option>
							<option value="1000" selected>1000</option>
							<option value="5000">5000</option>
						</select>
					</label>
					<a href={ templ.URL(fmt.Sprintf("/api/v1/containers/%s/logs/download?lines=1000", container.ID)) } class="btn btn-secondary" download>
						üì• Download Logs
					</a>
				</div>

				<div id="logs-container" style="background: #1a1a1a; color: #00ff00; padding: 1rem; border-radius: 4px; font-family: 'Courier New', monospace; font-size: 0.85rem; max-height: 600px; overflow-y: auto; white-space: pre-wrap; word-wrap: break-word;">
					<div hx-get={ fmt.Sprintf("/api/v1/containers/%s/logs?tail=1000", container.ID) } hx-trigger="load, every 5s" hx-swap="innerHTML">
						Loading logs...
					</div>
				</div>
			</div>
		</div>

		<script>
			// Auto-refresh toggle
			document.getElementById('auto-refresh').addEventListener('change', function(e) {
				const logsDiv = document.querySelector('#logs-container > div');
				if (e.target.checked) {
					logsDiv.setAttribute('hx-trigger', 'load, every 5s');
				} else {
					logsDiv.setAttribute('hx-trigger', 'load');
				}
				htmx.process(logsDiv);
			});

			// Lines selector
			document.getElementById('lines-select').addEventListener('change', function(e) {
				const lines = e.target.value;
				const logsDiv = document.querySelector('#logs-container > div');
				const containerID = '{ container.ID }';
				logsDiv.setAttribute('hx-get', `/api/v1/containers/${containerID}/logs?tail=${lines}`);
				htmx.trigger(logsDiv, 'load');

				// Update download link
				const downloadLink = document.querySelector('a[download]');
				downloadLink.href = `/api/v1/containers/${containerID}/logs/download?lines=${lines}`;
			});

			// Auto-scroll to bottom on new content
			const logsContainer = document.getElementById('logs-container');
			const observer = new MutationObserver(() => {
				logsContainer.scrollTop = logsContainer.scrollHeight;
			});
			observer.observe(logsContainer, { childList: true, subtree: true });
		</script>
	}
}

templ StacksListWithUser(stacks []*models.Stack, pagination PaginationInfo, user *models.User) {
	@LayoutWithUser("Stacks", user) {
		<div class="page-header">
			<h2>Stacks</h2>
			<div class="filters">
				<a href="/web/stacks/jsonld/deploy" class="btn btn-primary">+ Deploy New Stack</a>
			</div>
		</div>
		<div class="table-container" id="stacks-table" hx-get="/web/stacks/table" hx-trigger="load" hx-swap="innerHTML">
			<div class="loading">Loading stacks...</div>
		</div>
	}
}

templ StacksTableWithPagination(stacks []*models.Stack, pagination PaginationInfo, queryParams string) {
	if len(stacks) == 0 {
		<div class="empty-state">
			<p>No stacks deployed yet</p>
			<p><a href="/web/stacks/jsonld/deploy" class="btn btn-primary">Deploy Your First Stack</a></p>
		</div>
	} else {
		<table class="data-table">
			<thead>
				<tr>
					<th>Name</th>
					<th>Status</th>
					<th>Datacenter</th>
					<th>Mode</th>
					<th>Strategy</th>
					<th>Deployed</th>
					<th>Actions</th>
				</tr>
			</thead>
			<tbody>
				for _, stack := range stacks {
					<tr>
						<td>
							<a href={ templ.URL("/web/stacks/" + stack.ID) } style="text-decoration: none; color: inherit;">{ stack.Name }</a>
							if stack.Description != "" {
								<br/><small class="text-muted">{ stack.Description }</small>
							}
						</td>
						<td>
							<span class={ "badge badge-" + stack.Status }>{ stack.Status }</span>
						</td>
						<td>{ stack.Datacenter }</td>
						<td>{ stack.Deployment.Mode }</td>
						<td>{ stack.Deployment.PlacementStrategy }</td>
						<td>
							if stack.DeployedAt != nil {
								{ stack.DeployedAt.Format("2006-01-02 15:04") }
							} else {
								<span class="text-muted">Not deployed</span>
							}
						</td>
						<td>
							<a href={ templ.URL("/web/stacks/" + stack.ID) } class="btn btn-sm btn-secondary">View</a>
						</td>
					</tr>
				}
			</tbody>
		</table>
	}
}

templ StackDetailWithUser(stack *models.Stack, deployment *models.StackDeployment, containers []*models.Container, user *models.User) {
	@LayoutWithUser("Stack Detail", user) {
		<div class="page-header">
			<div>
				<h2>{ stack.Name }</h2>
				if stack.Description != "" {
					<p>{ stack.Description }</p>
				}
			</div>
			<div class="page-actions">
				<a href="/web/stacks" class="btn btn-secondary">Back to Stacks</a>
				<span class={ "badge badge-" + stack.Status }>{ stack.Status }</span>
				<a href={ templ.URL(fmt.Sprintf("/web/stacks/%s/edit", stack.ID)) } class="btn btn-secondary">Edit</a>
				if stack.Status == "running" {
					<form method="POST" action={ templ.URL(fmt.Sprintf("/web/stacks/%s/stop", stack.ID)) } id="stop-stack-form" style="display: inline;">
						<button type="button" class="btn btn-warning" data-stack-name={ stack.Name } onclick="showConfirmModal('Stop Stack', 'Are you sure you want to stop stack &quot;' + this.dataset.stackName + '&quot;?', 'Stop', function() { document.getElementById('stop-stack-form').submit(); })">Stop</button>
					</form>
					<form method="POST" action={ templ.URL(fmt.Sprintf("/web/stacks/%s/restart", stack.ID)) } id="restart-stack-form" style="display: inline;">
						<button type="button" class="btn btn-warning" data-stack-name={ stack.Name } onclick="showConfirmModal('Restart Stack', 'Are you sure you want to restart stack &quot;' + this.dataset.stackName + '&quot;?', 'Restart', function() { document.getElementById('restart-stack-form').submit(); })">Restart</button>
					</form>
				} else if stack.Status == "stopped" {
					<form method="POST" action={ templ.URL(fmt.Sprintf("/web/stacks/%s/start", stack.ID)) } style="display: inline;">
						<button type="submit" class="btn btn-success">Start</button>
					</form>
				}
				<form method="POST" action={ templ.URL(fmt.Sprintf("/web/stacks/%s/delete", stack.ID)) } id="delete-stack-form" style="display: inline;">
					<button type="button" class="btn btn-danger" data-stack-name={ stack.Name } onclick="showConfirmModal('Delete Stack', 'Are you sure you want to delete stack &quot;' + this.dataset.stackName + '&quot;? This will delete all containers in the stack. This action cannot be undone.', 'Delete', function() { document.getElementById('delete-stack-form').submit(); })">Delete</button>
				</form>
			</div>
		</div>
		<div class="detail-container">
			<div class="detail-section">
				<h3>Stack Information</h3>
				<dl class="detail-list">
					<dt>Stack ID</dt>
					<dd>{ stack.ID }</dd>
					<dt>Datacenter</dt>
					<dd>{ stack.Datacenter }</dd>
					<dt>Deployment Mode</dt>
					<dd>{ stack.Deployment.Mode }</dd>
					<dt>Placement Strategy</dt>
					<dd>{ stack.Deployment.PlacementStrategy }</dd>
					<dt>Network Mode</dt>
					<dd>{ stack.Deployment.NetworkMode }</dd>
					<dt>Owner</dt>
					<dd>{ stack.Owner }</dd>
					<dt>Created</dt>
					<dd>{ stack.CreatedAt.Format("2006-01-02 15:04:05") }</dd>
					if stack.DeployedAt != nil {
						<dt>Deployed</dt>
						<dd>{ stack.DeployedAt.Format("2006-01-02 15:04:05") }</dd>
					}
				</dl>
			</div>
			if len(containers) > 0 {
				<div class="detail-section">
					<h3>Assigned Containers ({ fmt.Sprintf("%d", len(containers)) })</h3>
					<table class="data-table">
						<thead>
							<tr>
								<th>Name</th>
								<th>Image</th>
								<th>Status</th>
								<th>Host</th>
								<th>Actions</th>
							</tr>
						</thead>
						<tbody>
							for _, container := range containers {
								<tr>
									<td>
										<a href={ templ.URL(fmt.Sprintf("/web/containers/%s", container.ID)) } style="text-decoration: none; color: inherit;">{ container.Name }</a>
									</td>
									<td>{ container.Image }</td>
									<td>
										<span class={ "badge badge-" + container.Status }>{ container.Status }</span>
									</td>
									<td>{ container.HostedOn }</td>
									<td>
										<div class="action-buttons">
											<a href={ templ.URL(fmt.Sprintf("/web/containers/%s", container.ID)) } class="btn-icon" title="View Details">üëÅÔ∏è</a>
											<a href={ templ.URL(fmt.Sprintf("/web/containers/%s/logs", container.ID)) } class="btn-icon" title="View Logs">üìÑ</a>
										</div>
									</td>
								</tr>
							}
						</tbody>
					</table>
				</div>
			}
			if deployment != nil && len(deployment.Placements) > 0 {
				<div class="detail-section">
					<h3>Container Placements</h3>
					<table class="data-table">
						<thead>
							<tr>
								<th>Container</th>
								<th>Host</th>
								<th>IP Address</th>
								<th>Ports</th>
								<th>Status</th>
								<th>Actions</th>
							</tr>
						</thead>
						<tbody>
							for _, placement := range deployment.Placements {
								<tr>
									<td>{ placement.ContainerName }</td>
									<td>{ placement.HostID }</td>
									<td>{ placement.IPAddress }</td>
									<td>
										for containerPort, hostPort := range placement.Ports {
											<span class="port-mapping">{ fmt.Sprintf("%d:%d", containerPort, hostPort) }</span>
										}
									</td>
									<td>
										<span class={ "badge badge-" + placement.Status }>{ placement.Status }</span>
									</td>
									<td>
										<div class="action-buttons">
											<a href={ templ.URL(fmt.Sprintf("/web/containers/%s", placement.ContainerID)) } class="btn-icon" title="View Details">üëÅÔ∏è</a>
											<a href={ templ.URL(fmt.Sprintf("/web/containers/%s/logs", placement.ContainerID)) } class="btn-icon" title="View Logs">üìÑ</a>
										</div>
									</td>
								</tr>
							}
						</tbody>
					</table>
				</div>
			}
			if deployment != nil && len(deployment.NetworkConfig.ServiceEndpoints) > 0 {
				<div class="detail-section">
					<h3>Service Endpoints</h3>
					<dl class="detail-list">
						for serviceName, endpoint := range deployment.NetworkConfig.ServiceEndpoints {
							<dt>{ serviceName }</dt>
							<dd>{ endpoint }</dd>
						}
					</dl>
				</div>
			}
			if stack.ErrorMessage != "" {
				<div class="detail-section error">
					<h3>Error</h3>
					<p>{ stack.ErrorMessage }</p>
				</div>
			}
		</div>
	}
}

// Deploy stack form template
templ DeployStackFormWithUser(templates []StackTemplate, hosts []*models.Host, containers []*models.Container, datacenters map[string]bool, errorMsg string, user *models.User) {
	@LayoutWithUser("Deploy Stack", user) {
		<div class="page-header">
			<div>
				<h2>Deploy New Stack</h2>
				<p>Deploy a multi-container stack from a JSON-LD definition</p>
			</div>
			<div class="page-actions">
				<a href="/web/stacks" class="btn btn-secondary">‚Üê Back to Stacks</a>
			</div>
		</div>
		if errorMsg != "" {
			<div class="alert alert-error">
				{ errorMsg }
			</div>
		}
		<div class="form-container">
			<form method="POST" action="/web/stacks/deploy" class="stack-form">
				<div class="form-section">
					<h3>Stack Template</h3>
					<p class="form-help">Select a predefined template or write your own JSON-LD definition</p>
					if len(templates) > 0 {
						<div class="form-group">
							<label for="template-selector">Choose Template (Optional)</label>
							<select id="template-selector" class="form-select">
								<option value="">-- Custom Definition --</option>
								for _, tmpl := range templates {
									<option value={ tmpl.Content }>{ tmpl.Name } - { tmpl.Description }</option>
								}
							</select>
							<small class="form-text">Select a template to auto-fill the JSON editor below</small>
						</div>
					}
					<div class="form-group">
						<label for="stack_json">Stack Definition (JSON-LD) *</label>
						<textarea
							id="stack_json"
							name="stack_json"
							rows="20"
							class="form-textarea code-editor"
							required
							placeholder={`{
  "@context": "https://schema.org",
  "@type": "ItemList",
  "name": "my-stack",
  "description": "My application stack",
  "network": {
    "name": "my-network",
    "driver": "bridge"
  },
  "itemListElement": [
    {
      "@type": "SoftwareApplication",
      "position": 1,
      "name": "nginx",
      "image": "nginx:latest",
      "ports": [
        {"containerPort": 80, "hostPort": 8080}
      ]
    }
  ]
}`}></textarea>
						<small class="form-text">JSON-LD format using Schema.org vocabulary</small>
					</div>
				</div>
				<div class="form-section">
					<h3>Deployment Configuration</h3>
					<div class="form-group">
						<label for="deployment-mode">Deployment Mode</label>
						<select id="deployment-mode" name="deployment_mode" class="form-select">
							<option value="distributed" selected>Distributed - Deploy across multiple hosts</option>
							<option value="single-host">Single Host - Deploy on one host</option>
						</select>
					</div>
					<div class="form-group">
						<label for="placement-strategy">Placement Strategy</label>
						<select id="placement-strategy" name="placement_strategy" class="form-select">
							<option value="auto" selected>Auto - Graphium decides based on resources</option>
							<option value="spread">Spread - Distribute evenly across hosts</option>
							<option value="datacenter">Datacenter - Keep in same datacenter</option>
							<option value="manual">Manual - Specify host per container</option>
						</select>
					</div>
					if len(datacenters) > 0 {
						<div class="form-group">
							<label for="datacenter">Target Datacenter (Optional)</label>
							<select id="datacenter" name="datacenter" class="form-select">
								<option value="">-- Any Datacenter --</option>
								for dc := range datacenters {
									<option value={ dc }>{ dc }</option>
								}
							</select>
						</div>
					}
					if len(hosts) > 0 {
						<div class="form-group">
							<label>Target Hosts (Optional)</label>
							<small class="form-text">Select specific hosts for deployment. If none selected, will use all active hosts in selected datacenter (or all active hosts if no datacenter selected).</small>
							<div class="host-selection" style="margin-top: 10px; max-height: 200px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 4px; padding: 10px;">
								for _, host := range hosts {
									<label class="checkbox-label" style="display: block; padding: 5px 0;">
										<input type="checkbox" name="target_hosts[]" value={ host.ID }/>
										<span>
											<strong>{ host.Name }</strong> ({ host.ID })
											if host.Datacenter != "" {
												<span class="text-muted"> - { host.Datacenter }</span>
											}
											<span class="text-muted"> - { host.IPAddress }</span>
											<span class={ "badge badge-" + host.Status } style="margin-left: 10px;">{ host.Status }</span>
										</span>
									</label>
								}
							</div>
						</div>
					} else {
						<div class="alert alert-warning">
							<strong>No Active Hosts Available!</strong> You need to register and activate at least one host before deploying stacks.
						</div>
					}
					if len(containers) > 0 {
						<div class="form-group">
							<label>Existing Containers (Optional)</label>
							<small class="form-text">Select existing containers to include in this stack. This allows you to group running containers into a logical stack without redeploying them.</small>
							<div class="container-selection" style="margin-top: 10px; max-height: 300px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 4px; padding: 10px;">
								for _, container := range containers {
									<label class="checkbox-label" style="display: block; padding: 5px 0;">
										<input type="checkbox" name="existing_containers[]" value={ container.ID }/>
										<span>
											<strong>{ container.Name }</strong>
											<span class="text-muted"> - { container.Image }</span>
											<span class={ "badge badge-" + container.Status } style="margin-left: 10px;">{ container.Status }</span>
											<br/>
											<small class="text-muted">{ container.ID[:12] } on { container.HostedOn }</small>
										</span>
									</label>
								}
							</div>
						</div>
					}
				</div>
				<div class="form-actions">
					<button type="submit" class="btn btn-primary">Deploy Stack</button>
					<a href="/web/stacks" class="btn btn-secondary">Cancel</a>
				</div>
			</form>
		</div>
		<script>
			// Template selector functionality
			const templateSelector = document.getElementById('template-selector');
			const jsonTextarea = document.getElementById('stack_json');
			let validationTimeout;

			if (templateSelector && jsonTextarea) {
				templateSelector.addEventListener('change', function() {
					if (this.value) {
						// Pretty print the JSON
						try {
							const formatted = JSON.stringify(JSON.parse(this.value), null, 2);
							jsonTextarea.value = formatted;
							validateJSON();
						} catch (e) {
							jsonTextarea.value = this.value;
						}
					}
				});

				// Real-time JSON validation
				jsonTextarea.addEventListener('input', function() {
					clearTimeout(validationTimeout);
					validationTimeout = setTimeout(validateJSON, 500);
				});

				// Initial validation
				if (jsonTextarea.value.trim()) {
					validateJSON();
				}
			}

			function validateJSON() {
				const jsonStr = jsonTextarea.value.trim();

				// Remove any existing validation messages
				const existingMsg = document.getElementById('json-validation');
				if (existingMsg) {
					existingMsg.remove();
				}

				if (!jsonStr) {
					return;
				}

				const validationDiv = document.createElement('div');
				validationDiv.id = 'json-validation';
				validationDiv.style.marginTop = '10px';
				validationDiv.style.padding = '10px';
				validationDiv.style.borderRadius = '4px';

				try {
					const parsed = JSON.parse(jsonStr);

					// Check required fields
					const errors = [];
					if (!parsed.name) {
						errors.push('Missing required field: "name"');
					}
					if (!parsed.itemListElement || !Array.isArray(parsed.itemListElement)) {
						errors.push('Missing or invalid "itemListElement" array');
					} else if (parsed.itemListElement.length === 0) {
						errors.push('Stack must contain at least one container');
					}

					if (errors.length > 0) {
						validationDiv.className = 'alert alert-warning';
						validationDiv.innerHTML = '<strong>Validation Warnings:</strong><ul style="margin: 5px 0 0 20px;">' +
							errors.map(e => '<li>' + e + '</li>').join('') + '</ul>';
					} else {
						validationDiv.className = 'alert alert-success';
						validationDiv.innerHTML = '‚úì Valid stack definition (' + parsed.itemListElement.length + ' container(s))';
					}
				} catch (e) {
					validationDiv.className = 'alert alert-error';
					validationDiv.innerHTML = '<strong>JSON Syntax Error:</strong> ' + e.message;
				}

				jsonTextarea.parentNode.appendChild(validationDiv);
			}
		</script>
	}
}

// Edit stack form template
templ EditStackFormWithUser(stack *models.Stack, containers []*models.Container, stackJSON string, errorMsg string, user *models.User) {
	@LayoutWithUser("Edit Stack", user) {
		<div class="page-header">
			<div>
				<a href={ templ.URL(fmt.Sprintf("/web/stacks/%s", stack.ID)) } class="btn btn-secondary">‚Üê Back to Stack</a>
				<h2>Edit Stack: { stack.Name }</h2>
				<p>Update stack metadata (name and description only)</p>
			</div>
		</div>
		if errorMsg != "" {
			<div class="alert alert-error">
				{ errorMsg }
			</div>
		}
		<div class="form-container">
			<form method="POST" action={ templ.URL(fmt.Sprintf("/web/stacks/%s/update", stack.ID)) } class="stack-form">
				<div class="form-section">
					<h3>Stack Information</h3>
					<div class="form-group">
						<label for="name">Stack Name *</label>
						<input type="text" id="name" name="name" value={ stack.Name } required/>
						<small class="form-text">Display name for this stack</small>
					</div>
					<div class="form-group">
						<label for="description">Description</label>
						<textarea id="description" name="description" rows="3" class="form-textarea">{ stack.Description }</textarea>
						<small class="form-text">Brief description of this stack's purpose</small>
					</div>
				</div>
				<div class="form-section">
					<h3>Current Configuration (Read-only)</h3>
					<div class="form-group">
						<label>Stack ID</label>
						<input type="text" value={ stack.ID } disabled/>
					</div>
					<div class="form-group">
						<label>Status</label>
						<input type="text" value={ stack.Status } disabled/>
					</div>
					<div class="form-group">
						<label>Placement Strategy</label>
						<input type="text" value={ stack.Deployment.PlacementStrategy } disabled/>
					</div>
					<div class="alert alert-info">
						<strong>Note:</strong> To change deployment configuration, you must redeploy the stack.
					</div>
				</div>
				if len(containers) > 0 {
					<div class="form-section">
						<h3>Manage Containers</h3>
						<p class="form-help">Select existing containers to assign to this stack</p>
						<div class="container-selection" style="margin-top: 10px; max-height: 400px; overflow-y: auto; border: 1px solid var(--border-color); border-radius: 4px; padding: 10px;">
							for _, container := range containers {
								<label class="checkbox-label" style="display: block; padding: 5px 0;">
									<input
										type="checkbox"
										name="stack_containers[]"
										value={ container.ID }
										if contains(stack.Containers, container.ID) {
											checked
										}
									/>
									<span>
										<strong>{ container.Name }</strong>
										<span class="text-muted"> - { container.Image }</span>
										<span class={ "badge badge-" + container.Status } style="margin-left: 10px;">{ container.Status }</span>
										<br/>
										<small class="text-muted">{ container.ID[:12] } on { container.HostedOn }</small>
									</span>
								</label>
							}
						</div>
						<small class="form-text">Check containers to add them to this stack, uncheck to remove them</small>
					</div>
				}
				<div class="form-actions">
					<button type="submit" class="btn btn-primary">Update Stack</button>
					<a href={ templ.URL(fmt.Sprintf("/web/stacks/%s", stack.ID)) } class="btn btn-secondary">Cancel</a>
				</div>
			</form>
		</div>
	}
}

// Stack logs aggregation view
templ StackLogsWithUser(stack *models.Stack, deployment *models.StackDeployment, containerIDs []string, user *models.User) {
	@LayoutWithUser("Stack Logs", user) {
		<div class="page-header">
			<div>
				<a href={ templ.URL(fmt.Sprintf("/web/stacks/%s", stack.ID)) } class="btn btn-secondary">‚Üê Back to Stack</a>
				<h2>Logs: { stack.Name }</h2>
				<p>Aggregated logs from all containers in this stack</p>
			</div>
			<div>
				<span class={ "badge badge-" + stack.Status }>{ stack.Status }</span>
			</div>
		</div>
		<div class="logs-container">
			if len(deployment.Placements) == 0 {
				<div class="empty-state">
					<p>No containers deployed in this stack</p>
				</div>
			} else {
				for _, placement := range deployment.Placements {
					<div class="log-section">
						<div class="log-header">
							<h3>{ placement.ContainerName }</h3>
							<div class="log-meta">
								<span class="log-host">Host: { placement.HostID }</span>
								<span class={ "badge badge-" + placement.Status }>{ placement.Status }</span>
							</div>
						</div>
						if placement.ContainerID != "" {
							<div class="log-content" id={ "logs-" + placement.ContainerID }>
								<div
									hx-get={ fmt.Sprintf("/web/containers/%s/logs?tail=100", placement.ContainerID) }
									hx-trigger="load"
									hx-swap="innerHTML">
									<div class="loading">Loading logs...</div>
								</div>
							</div>
						} else {
							<div class="log-content">
								<p class="text-muted">Container not yet created</p>
							</div>
						}
					</div>
				}
			}
		</div>
	}
}

// Create host form template
templ CreateHostFormWithUser(host *models.Host, errorMsg string, user *models.User) {
	@LayoutWithUser("Create Host", user) {
		<div class="page-header">
			<div>
				<h2>Register New Host</h2>
				<p>Add a new Docker host to your infrastructure</p>
			</div>
			<div class="page-actions">
				<a href="/web/hosts" class="btn btn-secondary">‚Üê Back to Hosts</a>
			</div>
		</div>
		if errorMsg != "" {
			<div class="alert alert-error">
				{ errorMsg }
			</div>
		}
		<div class="form-container">
			<form method="POST" action="/web/hosts/create" class="host-form">
				<div class="form-section">
					<h3>Host Information</h3>
					<div class="form-group">
						<label for="id">Host ID *</label>
						<input type="text" id="id" name="id" value={ host.ID } required placeholder="host-001"/>
						<small class="form-text">Unique identifier (e.g., host-001, web-server-01)</small>
					</div>
					<div class="form-group">
						<label for="name">Host Name *</label>
						<input type="text" id="name" name="name" value={ host.Name } required placeholder="localhost-docker"/>
						<small class="form-text">Friendly display name</small>
					</div>
					<div class="form-group">
						<label for="ipAddress">IP Address *</label>
						<input type="text" id="ipAddress" name="ipAddress" value={ host.IPAddress } required placeholder="localhost or 192.168.1.100"/>
						<small class="form-text">Use "localhost" for local Docker, or IP address for remote hosts</small>
					</div>
					<div class="form-group">
						<label for="datacenter">Datacenter / Location</label>
						<input type="text" id="datacenter" name="datacenter" value={ host.Datacenter } placeholder="us-west, europe, etc."/>
						<small class="form-text">Optional: Group hosts by location</small>
					</div>
				</div>
				<div class="form-section">
					<h3>Resources</h3>
					<div class="form-group">
						<label for="cpu">CPU Cores</label>
						<input type="number" id="cpu" name="cpu" value={ fmt.Sprintf("%d", host.CPU) } min="1" placeholder="4"/>
						<small class="form-text">Number of CPU cores available</small>
					</div>
					<div class="form-group">
						<label for="memory">Memory (bytes)</label>
						<input type="number" id="memory" name="memory" value={ fmt.Sprintf("%d", host.Memory) } min="0" placeholder="8589934592"/>
						<small class="form-text">Total memory in bytes (8589934592 = 8GB)</small>
					</div>
				</div>
				<div class="form-section">
					<h3>Status</h3>
					<div class="form-group">
						<label for="status">Status *</label>
						<select id="status" name="status" class="form-select" required>
							<option value="active" selected?={ host.Status == "active" }>Active - Ready for deployments</option>
							<option value="maintenance" selected?={ host.Status == "maintenance" }>Maintenance - Temporarily unavailable</option>
							<option value="offline" selected?={ host.Status == "offline" }>Offline - Not accessible</option>
						</select>
					</div>
				</div>
				<div class="alert alert-info">
					<strong>Docker Connection:</strong> Ensure Docker is running and accessible on this host.
					<ul style="margin: 10px 0 0 20px;">
						<li><strong>localhost</strong>: Will use unix:///var/run/docker.sock</li>
						<li><strong>Remote IP</strong>: Will use tcp://IP:2375 (ensure Docker API is exposed)</li>
					</ul>
				</div>
				<div class="form-actions">
					<button type="submit" class="btn btn-primary">Create Host</button>
					<a href="/web/hosts" class="btn btn-secondary">Cancel</a>
				</div>
			</form>
		</div>
	}
}

// Edit host form template
templ EditHostFormWithUser(host *models.Host, errorMsg string, user *models.User) {
	@LayoutWithUser("Edit Host", user) {
		<div class="page-header">
			<div>
				<a href={ templ.URL(fmt.Sprintf("/web/hosts/%s", host.ID)) } class="btn btn-secondary">‚Üê Back to Host</a>
				<h2>Edit Host: { host.Name }</h2>
			</div>
		</div>
		if errorMsg != "" {
			<div class="alert alert-error">
				{ errorMsg }
			</div>
		}
		<div class="form-container">
			<form method="POST" action={ templ.URL(fmt.Sprintf("/web/hosts/%s/update", host.ID)) } class="host-form">
				<div class="form-section">
					<h3>Host Information</h3>
					<div class="form-group">
						<label>Host ID</label>
						<input type="text" value={ host.ID } disabled/>
						<small class="form-text">Cannot be changed</small>
					</div>
					<div class="form-group">
						<label for="name">Host Name *</label>
						<input type="text" id="name" name="name" value={ host.Name } required/>
					</div>
					<div class="form-group">
						<label for="ipAddress">IP Address *</label>
						<input type="text" id="ipAddress" name="ipAddress" value={ host.IPAddress } required/>
						<small class="form-text">Use "localhost" for local, or IP for remote</small>
					</div>
					<div class="form-group">
						<label for="datacenter">Datacenter / Location</label>
						<input type="text" id="datacenter" name="datacenter" value={ host.Datacenter }/>
					</div>
				</div>
				<div class="form-section">
					<h3>Resources</h3>
					<div class="form-group">
						<label for="cpu">CPU Cores</label>
						<input type="number" id="cpu" name="cpu" value={ fmt.Sprintf("%d", host.CPU) } min="1"/>
					</div>
					<div class="form-group">
						<label for="memory">Memory (bytes)</label>
						<input type="number" id="memory" name="memory" value={ fmt.Sprintf("%d", host.Memory) } min="0"/>
					</div>
				</div>
				<div class="form-section">
					<h3>Status</h3>
					<div class="form-group">
						<label for="status">Status *</label>
						<select id="status" name="status" class="form-select" required>
							<option value="active" selected?={ host.Status == "active" }>Active</option>
							<option value="maintenance" selected?={ host.Status == "maintenance" }>Maintenance</option>
							<option value="offline" selected?={ host.Status == "offline" }>Offline</option>
						</select>
					</div>
				</div>
				<div class="form-actions">
					<button type="submit" class="btn btn-primary">Update Host</button>
					<a href={ templ.URL(fmt.Sprintf("/web/hosts/%s", host.ID)) } class="btn btn-secondary">Cancel</a>
				</div>
			</form>
		</div>
	}
}

// JSONLDDeployPage renders the JSON-LD stack deployment page
templ JSONLDDeployPage(user *models.User, validationResult *parseResultResponse, errorMsg string) {
	@LayoutWithUser("Deploy Stack (JSON-LD)", user) {
		<div class="container">
			<div class="page-header">
				<h1>Deploy Stack (JSON-LD)</h1>
				<p>Deploy containers using JSON-LD @graph format with semantic relationships</p>
			</div>
			if errorMsg != "" {
				<div class="alert alert-error">
					{ errorMsg }
				</div>
			}
			if validationResult != nil {
				if validationResult.Valid {
					<div class="alert alert-success">
						<strong>Validation Passed!</strong>
						<ul>
							<li>Stack: { validationResult.StackName }</li>
							<li>Containers: { fmt.Sprintf("%d", validationResult.ContainerCount) }</li>
							<li>Waves: { fmt.Sprintf("%d", validationResult.WaveCount) }</li>
							if validationResult.HasNetwork {
								<li>Custom network defined</li>
							}
						</ul>
						if len(validationResult.Warnings) > 0 {
							<strong>Warnings:</strong>
							<ul>
								for _, warning := range validationResult.Warnings {
									<li>{ warning }</li>
								}
							</ul>
						}
					</div>
				} else {
					<div class="alert alert-error">
						<strong>Validation Failed!</strong>
						<ul>
							for _, err := range validationResult.Errors {
								<li>{ err }</li>
							}
						</ul>
					</div>
				}
			}
			<div class="card">
				<form method="POST" action="/web/stacks/jsonld/deploy">
					<div class="form-group">
						<label for="stackDefinition">Stack Definition (JSON-LD)</label>
						<textarea
							id="stackDefinition"
							name="stackDefinition"
							rows="20"
							style="font-family: monospace; font-size: 12px;"
							placeholder='Paste your JSON-LD stack definition here'
							required
						></textarea>
					</div>
					<div class="form-group">
						<label for="timeout">Timeout (seconds)</label>
						<input type="number" id="timeout" name="timeout" value="300" min="30" max="3600"/>
					</div>
					<div class="form-group">
						<label>
							<input type="checkbox" name="rollbackOnError" checked/>
							Rollback on error
						</label>
					</div>
					<div class="form-group">
						<label>
							<input type="checkbox" name="pullImages"/>
							Pull images before deployment
						</label>
					</div>
					<div class="form-actions">
						<button type="button" class="btn btn-secondary" hx-post="/web/stacks/jsonld/validate" hx-include="[name='stackDefinition']" hx-target="#validation-result">
							Validate
						</button>
						<button type="submit" class="btn btn-primary">Deploy Stack</button>
						<a href="/web/stacks" class="btn btn-secondary">View Deployments</a>
					</div>
				</form>
				<div id="validation-result" style="margin-top: 20px;"></div>
			</div>
			<div class="card" style="margin-top: 20px;">
				<h3>Documentation</h3>
				<p>The JSON-LD format uses Schema.org vocabulary with custom datacenter extensions:</p>
				<ul>
					<li><strong>{ "@context" }</strong>: Must be "https://schema.org"</li>
					<li><strong>{ "@graph" }</strong>: Array of related entities</li>
					<li><strong>Stack</strong>: Root entity with hasPart array of containers</li>
					<li><strong>Container</strong>: Individual container specifications</li>
				</ul>
				<p>See the example in the editor above for complete structure.</p>
			</div>
		</div>
	}
}

// JSONLDDeploymentDetailPage renders detailed deployment information
templ JSONLDDeploymentDetailPage(deployment *deploymentStateResponse, user *models.User) {
	@LayoutWithUser("Deployment Details", user) {
		<div class="container">
			<div class="page-header">
				<div>
					<h1>Deployment: { deployment.StackID }</h1>
					<p>ID: { deployment.ID }</p>
				</div>
				<div style="display: flex; gap: 10px;">
					<a href={ templ.URL(fmt.Sprintf("/web/stacks/%s", deployment.StackID)) } class="btn btn-primary">Manage Stack</a>
					<a href="/web/stacks" class="btn btn-secondary">Back to List</a>
				</div>
			</div>
			<div class="card">
				<h2>Status</h2>
				<div class="deployment-status">
					<div class="status-item">
						<label>Status:</label>
						<span class={ "status", "status-" + deployment.Status }>{ deployment.Status }</span>
					</div>
					<div class="status-item">
						<label>Phase:</label>
						<span>{ deployment.Phase }</span>
					</div>
					<div class="status-item">
						<label>Progress:</label>
						<div class="progress-bar" style="width: 300px;">
							<div class="progress-fill" style={ fmt.Sprintf("width: %d%%", deployment.Progress) }></div>
						</div>
						{ fmt.Sprintf("%d%%", deployment.Progress) }
					</div>
					<div class="status-item">
						<label>Started:</label>
						<span>{ deployment.StartedAt.Format("2006-01-02 15:04:05") }</span>
					</div>
					if deployment.CompletedAt != nil {
						<div class="status-item">
							<label>Completed:</label>
							<span>{ deployment.CompletedAt.Format("2006-01-02 15:04:05") }</span>
						</div>
					}
					if deployment.ErrorMessage != "" {
						<div class="alert alert-error">
							<strong>Error:</strong> { deployment.ErrorMessage }
						</div>
					}
				</div>
			</div>
			if len(deployment.Placements) > 0 {
				<div class="card">
					<h2>Container Placements</h2>
					<table>
						<thead>
							<tr>
								<th>Container</th>
								<th>Host</th>
								<th>Container ID</th>
								<th>Status</th>
							</tr>
						</thead>
						<tbody>
							for containerName, placement := range deployment.Placements {
								<tr>
									<td>{ containerName }</td>
									<td>{ placement.HostID }</td>
									<td>
										if placement.ContainerID != "" {
											<code>{ placement.ContainerID[:12] }</code>
										} else {
											<em>Not created</em>
										}
									</td>
									<td>
										<span class={ "status", "status-" + placement.Status }>{ placement.Status }</span>
									</td>
								</tr>
							}
						</tbody>
					</table>
				</div>
			}
			if deployment.NetworkInfo != nil {
				<div class="card">
					<h2>Network Information</h2>
					<div class="info-grid">
						<div class="info-item">
							<label>Network Name:</label>
							<span>{ deployment.NetworkInfo.NetworkName }</span>
						</div>
						<div class="info-item">
							<label>Network ID:</label>
							<span><code>{ deployment.NetworkInfo.NetworkID[:12] }</code></span>
						</div>
						<div class="info-item">
							<label>Driver:</label>
							<span>{ deployment.NetworkInfo.Driver }</span>
						</div>
					</div>
				</div>
			}
			if len(deployment.Events) > 0 {
				<div class="card">
					<h2>Deployment Events</h2>
					<div class="events-list">
						for _, event := range deployment.Events {
							<div class={ "event", "event-" + event.Type }>
								<div class="event-header">
									<span class="event-time">{ event.Timestamp.Format("15:04:05") }</span>
									<span class={ "event-level", "level-" + event.Type }>{ event.Type }</span>
									<span class="event-phase">{ event.Phase }</span>
								</div>
								<div class="event-body">
									if event.Container != "" {
										<strong>{ event.Container }:</strong>
									}
									{ event.Message }
								</div>
							</div>
						}
					</div>
				</div>
			}
			if deployment.RollbackState != nil {
				<div class="card">
					<h2>Rollback Information</h2>
					<div class="alert alert-warning">
						<p><strong>Rollback { deployment.RollbackState.Status }</strong></p>
						<p>Started: { deployment.RollbackState.StartedAt.Format("2006-01-02 15:04:05") }</p>
						if deployment.RollbackState.CompletedAt != nil {
							<p>Completed: { deployment.RollbackState.CompletedAt.Format("2006-01-02 15:04:05") }</p>
						}
						if len(deployment.RollbackState.RemovedContainers) > 0 {
							<p>Removed containers:</p>
							<ul>
								for _, containerName := range deployment.RollbackState.RemovedContainers {
									<li>{ containerName }</li>
								}
							</ul>
						}
						if deployment.RollbackState.ErrorMessage != "" {
							<p><strong>Error:</strong> { deployment.RollbackState.ErrorMessage }</p>
						}
					</div>
				</div>
			}
		</div>
	}
}

// ============================================================================
// AGENTS TEMPLATES
// ============================================================================

// Agent list page with user
templ AgentsListWithUser(agents []AgentInfo, user *models.User) {
	@LayoutWithUser("Agents", user) {
		<div class="page-header">
			<div class="flex-row">
				<h2>Agents</h2>
			</div>
			<div class="filters">
				<input
					type="text"
					name="search"
					class="search-input"
					placeholder="Search by name or host..."
					hx-get="/web/agents/table"
					hx-target="#agents-table"
					hx-trigger="keyup changed delay:300ms"
					hx-include="[name='status']"
				/>
				<select name="status" hx-get="/web/agents/table" hx-target="#agents-table" hx-trigger="change" hx-include="[name='search']">
					<option value="">All Statuses</option>
					<option value="running">Running</option>
					<option value="stopped">Stopped</option>
					<option value="failed">Failed</option>
				</select>
			</div>
		</div>

		<div id="agents-table">
			@AgentsTable(agents)
		</div>
	}
}

// AgentInfo combines config and state for display
type AgentInfo struct {
	Config *models.AgentConfig
	State  *models.AgentState
}

// Agents table component (for HTMX updates)
templ AgentsTable(agents []AgentInfo) {
	<div class="table-container">
		<table class="data-table">
			<thead>
				<tr>
					<th>Name</th>
					<th>Host ID</th>
					<th>Docker Socket</th>
					<th>Status</th>
					<th>Containers</th>
					<th>Last Heartbeat</th>
					<th>Actions</th>
				</tr>
			</thead>
			<tbody>
				if len(agents) == 0 {
					<tr>
						<td colspan="7" class="no-data">No agents found</td>
					</tr>
				}
				for _, agent := range agents {
					<tr>
						<td>
							<strong>{ agent.Config.Name }</strong>
							<br/>
							<small class="text-muted">{ agent.Config.ID }</small>
						</td>
						<td>{ agent.Config.HostID }</td>
						<td>
							<span class="text-muted">{ agent.Config.DockerSocket }</span>
						</td>
						<td>
							<span class={ fmt.Sprintf("badge badge-%s", getAgentStatusClass(agent.State.Status)) }>
								{ agent.State.Status }
							</span>
						</td>
						<td>{ fmt.Sprintf("%d", agent.State.ContainerCount) }</td>
						<td>
							if agent.State.LastHeartbeat != nil {
								<span class="text-muted">{ formatTimeAgo(*agent.State.LastHeartbeat) }</span>
							} else {
								<span class="text-muted">Never</span>
							}
						</td>
						<td>
							<div class="action-buttons">
								if agent.State.Status == "running" {
									<button
										class="btn-icon"
										title="Stop Agent"
										hx-post={ fmt.Sprintf("/web/agents/%s/stop", agent.Config.ID) }
										hx-target="#agents-table"
										hx-swap="outerHTML"
									>‚è∏Ô∏è</button>
									<button
										class="btn-icon"
										title="Restart Agent"
										hx-post={ fmt.Sprintf("/web/agents/%s/restart", agent.Config.ID) }
										hx-target="#agents-table"
										hx-swap="outerHTML"
									>üîÑ</button>
								} else {
									<button
										class="btn-icon"
										title="Start Agent"
										hx-post={ fmt.Sprintf("/web/agents/%s/start", agent.Config.ID) }
										hx-target="#agents-table"
										hx-swap="outerHTML"
									>‚ñ∂Ô∏è</button>
								}
								<a href={ templ.URL(fmt.Sprintf("/web/agents/%s", agent.Config.ID)) } class="btn-icon" title="View Details">üëÅÔ∏è</a>
								<button
									class="btn-icon btn-danger"
									title="Delete Agent"
									hx-delete={ fmt.Sprintf("/web/agents/%s", agent.Config.ID) }
									hx-target="#agents-table"
									hx-swap="outerHTML"
									hx-confirm="Are you sure you want to delete this agent?"
								>üóëÔ∏è</button>
							</div>
						</td>
					</tr>
				}
			</tbody>
		</table>
		<div class="table-footer">
			<p>Total: { fmt.Sprintf("%d", len(agents)) } agents</p>
		</div>
	</div>
}

// Agent detail page with user
templ AgentDetailWithUser(agent AgentInfo, user *models.User) {
	@LayoutWithUser(fmt.Sprintf("Agent: %s", agent.Config.Name), user) {
		<div class="page-header">
			<div class="flex-row">
				<a href="/web/agents" class="btn btn-secondary">‚Üê Back to Agents</a>
			</div>
			<h2>Agent: { agent.Config.Name }</h2>
		</div>

		<div class="detail-grid">
			<div class="detail-card">
				<h3>Configuration</h3>
				<div class="detail-row">
					<span class="detail-label">ID:</span>
					<span class="detail-value">{ agent.Config.ID }</span>
				</div>
				<div class="detail-row">
					<span class="detail-label">Name:</span>
					<span class="detail-value">{ agent.Config.Name }</span>
				</div>
				<div class="detail-row">
					<span class="detail-label">Host ID:</span>
					<span class="detail-value">{ agent.Config.HostID }</span>
				</div>
				<div class="detail-row">
					<span class="detail-label">Docker Socket:</span>
					<span class="detail-value">{ agent.Config.DockerSocket }</span>
				</div>
				<div class="detail-row">
					<span class="detail-label">Datacenter:</span>
					<span class="detail-value">{ agent.Config.Datacenter }</span>
				</div>
				<div class="detail-row">
					<span class="detail-label">Sync Interval:</span>
					<span class="detail-value">{ fmt.Sprintf("%d seconds", agent.Config.SyncInterval) }</span>
				</div>
				<div class="detail-row">
					<span class="detail-label">Enabled:</span>
					<span class="detail-value">
						if agent.Config.Enabled {
							<span class="badge badge-success">Yes</span>
						} else {
							<span class="badge badge-secondary">No</span>
						}
					</span>
				</div>
				<div class="detail-row">
					<span class="detail-label">Auto Start:</span>
					<span class="detail-value">
						if agent.Config.AutoStart {
							<span class="badge badge-success">Yes</span>
						} else {
							<span class="badge badge-secondary">No</span>
						}
					</span>
				</div>
			</div>

			<div class="detail-card">
				<h3>Runtime State</h3>
				<div class="detail-row">
					<span class="detail-label">Status:</span>
					<span class="detail-value">
						<span class={ fmt.Sprintf("badge badge-%s", getAgentStatusClass(agent.State.Status)) }>
							{ agent.State.Status }
						</span>
					</span>
				</div>
				<div class="detail-row">
					<span class="detail-label">Process ID:</span>
					<span class="detail-value">
						if agent.State.ProcessID > 0 {
							{ fmt.Sprintf("%d", agent.State.ProcessID) }
						} else {
							<span class="text-muted">N/A</span>
						}
					</span>
				</div>
				<div class="detail-row">
					<span class="detail-label">Container Count:</span>
					<span class="detail-value">{ fmt.Sprintf("%d", agent.State.ContainerCount) }</span>
				</div>
				<div class="detail-row">
					<span class="detail-label">Started At:</span>
					<span class="detail-value">
						if agent.State.StartedAt != nil {
							{ agent.State.StartedAt.Format("2006-01-02 15:04:05") }
						} else {
							<span class="text-muted">N/A</span>
						}
					</span>
				</div>
				<div class="detail-row">
					<span class="detail-label">Last Heartbeat:</span>
					<span class="detail-value">
						if agent.State.LastHeartbeat != nil {
							{ agent.State.LastHeartbeat.Format("2006-01-02 15:04:05") }
							<small class="text-muted">({ formatTimeAgo(*agent.State.LastHeartbeat) })</small>
						} else {
							<span class="text-muted">Never</span>
						}
					</span>
				</div>
				<div class="detail-row">
					<span class="detail-label">Last Sync:</span>
					<span class="detail-value">
						if agent.State.LastSyncAt != nil {
							{ agent.State.LastSyncAt.Format("2006-01-02 15:04:05") }
						} else {
							<span class="text-muted">Never</span>
						}
					</span>
				</div>
				if agent.State.ErrorMessage != "" {
					<div class="detail-row">
						<span class="detail-label">Error:</span>
						<span class="detail-value text-danger">{ agent.State.ErrorMessage }</span>
					</div>
				}
			</div>
		</div>

		<div class="detail-actions">
			if agent.State.Status == "running" {
				<button
					class="btn btn-warning"
					hx-post={ fmt.Sprintf("/web/agents/%s/stop", agent.Config.ID) }
					hx-target="body"
					hx-swap="outerHTML"
				>‚è∏Ô∏è Stop Agent</button>
				<button
					class="btn btn-primary"
					hx-post={ fmt.Sprintf("/web/agents/%s/restart", agent.Config.ID) }
					hx-target="body"
					hx-swap="outerHTML"
				>üîÑ Restart Agent</button>
			} else {
				<button
					class="btn btn-success"
					hx-post={ fmt.Sprintf("/web/agents/%s/start", agent.Config.ID) }
					hx-target="body"
					hx-swap="outerHTML"
				>‚ñ∂Ô∏è Start Agent</button>
			}
			<button
				class="btn btn-danger"
				hx-delete={ fmt.Sprintf("/web/agents/%s", agent.Config.ID) }
				hx-confirm="Are you sure you want to delete this agent? This action cannot be undone."
				hx-target="body"
				hx-swap="outerHTML"
			>üóëÔ∏è Delete Agent</button>
		</div>
	}
}

// Helper function to get CSS class for agent status
func getAgentStatusClass(status string) string {
	switch status {
	case "running":
		return "success"
	case "stopped":
		return "secondary"
	case "failed":
		return "danger"
	case "starting":
		return "warning"
	case "stopping":
		return "warning"
	default:
		return "secondary"
	}
}

// Helper function to format time ago
func formatTimeAgo(t time.Time) string {
	duration := time.Since(t)

	if duration < time.Minute {
		return "just now"
	}
	if duration < time.Hour {
		minutes := int(duration.Minutes())
		if minutes == 1 {
			return "1 minute ago"
		}
		return fmt.Sprintf("%d minutes ago", minutes)
	}
	if duration < 24*time.Hour {
		hours := int(duration.Hours())
		if hours == 1 {
			return "1 hour ago"
		}
		return fmt.Sprintf("%d hours ago", hours)
	}
	days := int(duration.Hours() / 24)
	if days == 1 {
		return "1 day ago"
	}
	return fmt.Sprintf("%d days ago", days)
}
