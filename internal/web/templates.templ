package web

import (
	"fmt"
	"evalgo.org/graphium/models"
	"evalgo.org/graphium/internal/storage"
	"evalgo.org/graphium/internal/config"
)

// Base layout template
templ Layout(title string) {
	<!DOCTYPE html>
	<html lang="en">
	<head>
		<meta charset="UTF-8"/>
		<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
		<title>{ title } - Graphium</title>
		<script src="https://unpkg.com/htmx.org@1.9.10"></script>
		<script src="https://unpkg.com/htmx.org/dist/ext/ws.js"></script>
		<link rel="stylesheet" href="/static/css/styles.css"/>
	</head>
	<body>
		<nav class="navbar">
			<div class="nav-brand">
				<h1>üß¨ Graphium</h1>
				<p class="tagline">Container Intelligence Platform</p>
			</div>
			<ul class="nav-links">
				<li><a href="/" class="nav-link">Dashboard</a></li>
				<li><a href="/web/containers" class="nav-link">Containers</a></li>
				<li><a href="/web/hosts" class="nav-link">Hosts</a></li>
				<li><a href="/web/graph" class="nav-link">Graph</a></li>
				<li><a href="/web/topology" class="nav-link">Topology</a></li>
			</ul>
		</nav>
		<main class="container">
			{ children... }
		</main>
		<footer class="footer">
			<p>Graphium - Semantic Container Orchestration</p>
		</footer>
	</body>
	</html>
}

// Dashboard template
templ Dashboard(stats *storage.Statistics) {
	@Layout("Dashboard") {
		<div class="dashboard">
			<h2>Infrastructure Overview</h2>

			<div class="stats-grid">
				<div class="stat-card">
					<div class="stat-icon">üì¶</div>
					<div class="stat-content">
						<h3>Total Containers</h3>
						<p class="stat-value">{ fmt.Sprintf("%d", stats.TotalContainers) }</p>
					</div>
				</div>

				<div class="stat-card stat-success">
					<div class="stat-icon">‚ñ∂Ô∏è</div>
					<div class="stat-content">
						<h3>Running</h3>
						<p class="stat-value">{ fmt.Sprintf("%d", stats.RunningContainers) }</p>
					</div>
				</div>

				<div class="stat-card">
					<div class="stat-icon">üñ•Ô∏è</div>
					<div class="stat-content">
						<h3>Total Hosts</h3>
						<p class="stat-value">{ fmt.Sprintf("%d", stats.TotalHosts) }</p>
					</div>
				</div>

				<div class="stat-card stat-info">
					<div class="stat-icon">üìä</div>
					<div class="stat-content">
						<h3>Hosts with Containers</h3>
						<p class="stat-value">{ fmt.Sprintf("%d", len(stats.HostContainerCounts)) }</p>
					</div>
				</div>
			</div>

			if len(stats.HostContainerCounts) > 0 {
				<div class="section">
					<h3>Container Distribution</h3>
					<div class="distribution-grid">
						for hostID, count := range stats.HostContainerCounts {
							<div class="distribution-item">
								<span class="host-id">{ hostID }</span>
								<div class="distribution-bar">
									<div class="distribution-fill" style={ fmt.Sprintf("width: %d%%", (count * 100) / stats.TotalContainers) }></div>
								</div>
								<span class="container-count">{ fmt.Sprintf("%d", count) }</span>
							</div>
						}
					</div>
				</div>
			}

			<div class="quick-actions">
				<h3>Quick Actions</h3>
				<div class="action-buttons">
					<a href="/web/containers" class="btn btn-primary">View All Containers</a>
					<a href="/web/hosts" class="btn btn-secondary">View All Hosts</a>
					<a href="/web/topology" class="btn btn-info">View Topology</a>
				</div>
			</div>
		</div>
	}
}

// Containers list template
templ ContainersList(containers []*models.Container) {
	@Layout("Containers") {
		<div class="page-header">
			<h2>Containers</h2>
			<div class="filters" hx-get="/web/containers/table" hx-target="#containers-table" hx-trigger="change">
				<select name="status" hx-get="/web/containers/table" hx-target="#containers-table">
					<option value="">All Statuses</option>
					<option value="running">Running</option>
					<option value="stopped">Stopped</option>
					<option value="paused">Paused</option>
					<option value="exited">Exited</option>
				</select>
			</div>
		</div>

		<div id="containers-table">
			@ContainersTable(containers)
		</div>
	}
}

// Containers table component (for HTMX updates)
templ ContainersTable(containers []*models.Container) {
	<div class="table-container">
		<table class="data-table">
			<thead>
				<tr>
					<th>Name</th>
					<th>Image</th>
					<th>Status</th>
					<th>Host</th>
					<th>Created</th>
					<th>Actions</th>
				</tr>
			</thead>
			<tbody>
				if len(containers) == 0 {
					<tr>
						<td colspan="6" class="no-data">No containers found</td>
					</tr>
				}
				for _, container := range containers {
					<tr>
						<td>
							<strong>{ container.Name }</strong>
							<br/>
							<small class="text-muted">{ container.ID[:12] }</small>
						</td>
						<td>{ container.Image }</td>
						<td>
							<span class={ fmt.Sprintf("badge badge-%s", container.Status) }>
								{ container.Status }
							</span>
						</td>
						<td>{ container.HostedOn }</td>
						<td>{ container.Created }</td>
						<td>
							<div class="action-buttons">
								<button class="btn-icon" title="View Details">üëÅÔ∏è</button>
								<button class="btn-icon" title="View Logs">üìÑ</button>
							</div>
						</td>
					</tr>
				}
			</tbody>
		</table>
		<div class="table-footer">
			<p>Total: { fmt.Sprintf("%d", len(containers)) } containers</p>
		</div>
	</div>
}

// Hosts list template
templ HostsList(hosts []*models.Host) {
	@Layout("Hosts") {
		<div class="page-header">
			<h2>Hosts</h2>
			<div class="filters">
				<select name="status" hx-get="/web/hosts/table" hx-target="#hosts-table">
					<option value="">All Statuses</option>
					<option value="active">Active</option>
					<option value="inactive">Inactive</option>
					<option value="maintenance">Maintenance</option>
				</select>
			</div>
		</div>

		<div id="hosts-table">
			@HostsTable(hosts)
		</div>
	}
}

// Hosts table component (for HTMX updates)
templ HostsTable(hosts []*models.Host) {
	<div class="table-container">
		<table class="data-table">
			<thead>
				<tr>
					<th>Name</th>
					<th>IP Address</th>
					<th>CPU</th>
					<th>Memory</th>
					<th>Status</th>
					<th>Datacenter</th>
					<th>Actions</th>
				</tr>
			</thead>
			<tbody>
				if len(hosts) == 0 {
					<tr>
						<td colspan="7" class="no-data">No hosts found</td>
					</tr>
				}
				for _, host := range hosts {
					<tr>
						<td>
							<strong>{ host.Name }</strong>
							<br/>
							<small class="text-muted">{ host.ID }</small>
						</td>
						<td>{ host.IPAddress }</td>
						<td>{ fmt.Sprintf("%d cores", host.CPU) }</td>
						<td>{ fmt.Sprintf("%.1f GB", float64(host.Memory) / 1024 / 1024 / 1024) }</td>
						<td>
							<span class={ fmt.Sprintf("badge badge-%s", host.Status) }>
								{ host.Status }
							</span>
						</td>
						<td>{ host.Datacenter }</td>
						<td>
							<div class="action-buttons">
								<button class="btn-icon" title="View Details">üëÅÔ∏è</button>
								<button class="btn-icon" title="View Containers">üì¶</button>
							</div>
						</td>
					</tr>
				}
			</tbody>
		</table>
		<div class="table-footer">
			<p>Total: { fmt.Sprintf("%d", len(hosts)) } hosts</p>
		</div>
	</div>
}

// Topology view template
templ TopologyView(topology *storage.DatacenterTopology, datacenter string) {
	@Layout("Topology") {
		<div class="page-header">
			<h2>Infrastructure Topology</h2>
			<div class="filters">
				<select name="datacenter" hx-get="/web/topology" hx-target="main .container">
					<option value="all">All Datacenters</option>
					<option value="us-east">US East</option>
					<option value="us-west">US West</option>
					<option value="eu-west">EU West</option>
				</select>
			</div>
		</div>

		if topology != nil {
			<div class="topology-view">
				<div class="datacenter-info">
					<h3>Datacenter: { topology.Datacenter }</h3>
				</div>

				<div class="topology-grid">
					for hostID, hostTopo := range topology.Hosts {
						<div class="host-card">
							<div class="host-header">
								<h4>üñ•Ô∏è { hostTopo.Host.Name }</h4>
								<span class={ fmt.Sprintf("badge badge-%s", hostTopo.Host.Status) }>
									{ hostTopo.Host.Status }
								</span>
							</div>
							<div class="host-details">
								<p><strong>ID:</strong> { hostID }</p>
								<p><strong>IP:</strong> { hostTopo.Host.IPAddress }</p>
								<p><strong>CPU:</strong> { fmt.Sprintf("%d cores", hostTopo.Host.CPU) }</p>
								<p><strong>Memory:</strong> { fmt.Sprintf("%.1f GB", float64(hostTopo.Host.Memory) / 1024 / 1024 / 1024) }</p>
							</div>
							<div class="containers-section">
								<h5>Containers ({ fmt.Sprintf("%d", len(hostTopo.Containers)) })</h5>
								if len(hostTopo.Containers) > 0 {
									<ul class="container-list">
										for _, container := range hostTopo.Containers {
											<li class="container-item">
												<span class="container-name">{ container.Name }</span>
												<span class={ fmt.Sprintf("badge badge-%s badge-sm", container.Status) }>
													{ container.Status }
												</span>
											</li>
										}
									</ul>
								} else {
									<p class="no-data">No containers</p>
								}
							</div>
						</div>
					}
				</div>
			</div>
		} else {
			<div class="empty-state">
				<p>Select a datacenter to view topology</p>
			</div>
		}
	}
}

// Graph visualization template
templ GraphView(cfg *config.Config) {
	@Layout("Graph Visualization") {
		<div class="page-header">
			<h2>Infrastructure Graph</h2>
			<div class="filters">
				<div class="graph-control-group">
					<label for="layout-select">Layout:</label>
					<select id="layout-select" name="layout">
						<option value="cose">Force Directed (COSE)</option>
						<option value="grid">Grid</option>
						<option value="circle">Circle</option>
						<option value="breadthfirst">Hierarchical</option>
						<option value="concentric">Concentric</option>
					</select>
				</div>
				<div class="graph-control-group">
					<label for="filter-type">Node Type:</label>
					<select id="filter-type" name="type">
						<option value="all">All Types</option>
						<option value="host">Hosts Only</option>
						<option value="container">Containers Only</option>
					</select>
				</div>
				<div class="graph-control-group">
					<label for="filter-status">Status:</label>
					<select id="filter-status" name="status">
						<option value="all">All Status</option>
						<option value="running">Running</option>
						<option value="stopped">Stopped</option>
						<option value="paused">Paused</option>
					</select>
				</div>
				<div class="graph-control-group">
					<label for="filter-datacenter">Datacenter:</label>
					<select id="filter-datacenter" name="datacenter">
						<option value="all">All Datacenters</option>
					</select>
				</div>
				<button class="btn btn-secondary" id="btn-clear-filters">Clear Filters</button>
			</div>
		</div>

		<div class="graph-container">
			<div class="graph-legend">
				<div class="legend-item">
					<div class="legend-color host"></div>
					<span>Hosts</span>
				</div>
				<div class="legend-item">
					<div class="legend-color container-running"></div>
					<span>Running Containers</span>
				</div>
				<div class="legend-item">
					<div class="legend-color container-stopped"></div>
					<span>Stopped Containers</span>
				</div>
			</div>

			<div id="graph-stats" class="graph-stats">
				<div class="graph-stat-item">
					<div class="label">Total Nodes</div>
					<div class="value" id="stat-nodes">-</div>
				</div>
				<div class="graph-stat-item">
					<div class="label">Hosts</div>
					<div class="value" id="stat-hosts">-</div>
				</div>
				<div class="graph-stat-item">
					<div class="label">Containers</div>
					<div class="value" id="stat-containers">-</div>
				</div>
				<div class="graph-stat-item">
					<div class="label">Relationships</div>
					<div class="value" id="stat-edges">-</div>
				</div>
			</div>

			<div class="graph-controls">
				<div class="action-buttons">
					<button class="btn btn-primary" id="btn-fit">Fit to Screen</button>
					<button class="btn btn-secondary" id="btn-center">Center</button>
					<button class="btn btn-secondary" id="btn-refresh">Refresh Data</button>
					<button class="btn btn-secondary" id="btn-export-png">Export PNG</button>
					<button class="btn btn-secondary" id="btn-export-svg">Export SVG</button>
					<button class="btn btn-secondary" id="btn-export-json">Export JSON</button>
				</div>
			</div>

			<div id="cy"></div>
		</div>

		<script src="https://unpkg.com/cytoscape@3.26.0/dist/cytoscape.min.js"></script>
		<script>
		(function() {
			let cy;
			let originalData = { nodes: [], edges: [] };
			let currentFilters = { type: 'all', status: 'all', datacenter: 'all' };

			// Initialize Cytoscape
			function initGraph(layout = 'cose') {
				fetch('/api/v1/graph')
					.then(response => response.json())
					.then(data => {
						// Store original data
						originalData = {
							nodes: data.nodes || [],
							edges: data.edges || []
						};

						// Populate datacenter filter with unique datacenters
						populateDatacenterFilter(originalData.nodes);

						// Apply current filters
						const elements = applyFilters(originalData, currentFilters);

						// Update stats
						const stats = {
							nodes: elements.nodes.length,
							hosts: elements.nodes.filter(n => n.data.type === 'host').length,
							containers: elements.nodes.filter(n => n.data.type === 'container').length,
							edges: elements.edges.length
						};

						document.getElementById('stat-nodes').textContent = stats.nodes;
						document.getElementById('stat-hosts').textContent = stats.hosts;
						document.getElementById('stat-containers').textContent = stats.containers;
						document.getElementById('stat-edges').textContent = stats.edges;

						// Initialize or update graph
						if (cy) {
							cy.destroy();
						}

						cy = cytoscape({
							container: document.getElementById('cy'),
							elements: elements,
							style: [
								{
									selector: 'node',
									style: {
										'background-color': '#6366f1',
										'label': 'data(label)',
										'color': '#f1f5f9',
										'text-valign': 'center',
										'text-halign': 'center',
										'font-size': '12px',
										'width': 60,
										'height': 60,
										'border-width': 2,
										'border-color': '#8b5cf6'
									}
								},
								{
									selector: 'node[type="host"]',
									style: {
										'background-color': '#6366f1',
										'shape': 'rectangle',
										'width': 80,
										'height': 60,
										'border-color': '#4f46e5'
									}
								},
								{
									selector: 'node[type="container"]',
									style: {
										'background-color': '#10b981',
										'shape': 'ellipse',
										'width': 60,
										'height': 60
									}
								},
								{
									selector: 'node[status="stopped"]',
									style: {
										'background-color': '#94a3b8',
										'opacity': 0.7
									}
								},
								{
									selector: 'node[status="running"]',
									style: {
										'background-color': '#10b981'
									}
								},
								{
									selector: 'edge',
									style: {
										'width': 2,
										'line-color': '#475569',
										'target-arrow-color': '#475569',
										'target-arrow-shape': 'triangle',
										'curve-style': 'bezier',
										'arrow-scale': 1.5
									}
								},
								{
									selector: 'node:selected',
									style: {
										'border-width': 4,
										'border-color': '#f59e0b'
									}
								}
							],
							layout: {
								name: layout,
								animate: true,
								animationDuration: 500,
								fit: true,
								padding: 50,
								randomize: false,
								componentSpacing: 100,
								nodeRepulsion: 400000,
								idealEdgeLength: 100,
								edgeElasticity: 100
							}
						});

						// Add tooltips on hover
						cy.on('tap', 'node', function(evt) {
							const node = evt.target;
							const data = node.data();
							let info = `Type: ${data.type}\\nID: ${data.id}\\nStatus: ${data.status || 'N/A'}`;
							if (data.type === 'host') {
								info += `\\nIP: ${data.ip || 'N/A'}\\nCPU: ${data.cpu || 'N/A'}\\nMemory: ${data.memory ? (data.memory / 1024 / 1024 / 1024).toFixed(1) + ' GB' : 'N/A'}`;
							} else if (data.type === 'container') {
								info += `\\nImage: ${data.image || 'N/A'}`;
							}
							alert(info);
						});
					})
					.catch(error => {
						console.error('Failed to load graph data:', error);
						document.getElementById('cy').innerHTML = '<div class="graph-loading">Failed to load graph data</div>';
					});
			}

			// Layout selector
			document.getElementById('layout-select').addEventListener('change', function(e) {
				if (cy) {
					cy.layout({
						name: e.target.value,
						animate: true,
						animationDuration: 500,
						fit: true,
						padding: 50
					}).run();
				}
			});

			// Control buttons
			document.getElementById('btn-fit').addEventListener('click', function() {
				if (cy) cy.fit();
			});

			document.getElementById('btn-center').addEventListener('click', function() {
				if (cy) cy.center();
			});

			document.getElementById('btn-refresh').addEventListener('click', function() {
				const layout = document.getElementById('layout-select').value;
				initGraph(layout);
			});

			// Export button handlers
			document.getElementById('btn-export-png').addEventListener('click', function() {
				if (!cy) return;
				const png = cy.png({ full: true, scale: 2 });
				downloadFile(png, 'graphium-graph.png');
				showNotification('Graph exported as PNG', 'success');
			});

			document.getElementById('btn-export-svg').addEventListener('click', function() {
				if (!cy) return;
				const svg = cy.svg({ full: true, scale: 1 });
				const blob = new Blob([svg], { type: 'image/svg+xml' });
				const url = URL.createObjectURL(blob);
				downloadFile(url, 'graphium-graph.svg');
				URL.revokeObjectURL(url);
				showNotification('Graph exported as SVG', 'success');
			});

			document.getElementById('btn-export-json').addEventListener('click', function() {
				if (!cy) return;
				const graphData = {
					nodes: cy.nodes().map(node => node.json()),
					edges: cy.edges().map(edge => edge.json())
				};
				const json = JSON.stringify(graphData, null, 2);
				const blob = new Blob([json], { type: 'application/json' });
				const url = URL.createObjectURL(blob);
				downloadFile(url, 'graphium-graph.json');
				URL.revokeObjectURL(url);
				showNotification('Graph exported as JSON', 'success');
			});

			// Helper function to download files
			function downloadFile(url, filename) {
				const link = document.createElement('a');
				link.href = url;
				link.download = filename;
				document.body.appendChild(link);
				link.click();
				document.body.removeChild(link);
			}

			// Populate datacenter filter with unique datacenters from nodes
			function populateDatacenterFilter(nodes) {
				const datacenters = new Set();
				nodes.forEach(node => {
					if (node.data && node.data.datacenter) {
						datacenters.add(node.data.datacenter);
					}
				});

				const select = document.getElementById('filter-datacenter');
				// Keep the "All Datacenters" option
				select.innerHTML = '<option value="all">All Datacenters</option>';

				// Add unique datacenters
				Array.from(datacenters).sort().forEach(dc => {
					const option = document.createElement('option');
					option.value = dc;
					option.textContent = dc;
					select.appendChild(option);
				});
			}

			// Apply filters to graph data
			function applyFilters(data, filters) {
				let filteredNodes = data.nodes.filter(node => {
					const nodeData = node.data;

					// Filter by type
					if (filters.type !== 'all' && nodeData.type !== filters.type) {
						return false;
					}

					// Filter by status
					if (filters.status !== 'all' && nodeData.status !== filters.status) {
						return false;
					}

					// Filter by datacenter (for hosts and containers)
					if (filters.datacenter !== 'all' && nodeData.datacenter !== filters.datacenter) {
						return false;
					}

					return true;
				});

				// Get IDs of filtered nodes
				const nodeIds = new Set(filteredNodes.map(n => n.data.id));

				// Filter edges to only include those connecting visible nodes
				const filteredEdges = data.edges.filter(edge => {
					const source = edge.data.source;
					const target = edge.data.target;
					return nodeIds.has(source) && nodeIds.has(target);
				});

				return {
					nodes: filteredNodes,
					edges: filteredEdges
				};
			}

			// Reapply filters and redraw graph
			function reapplyFilters() {
				const layout = document.getElementById('layout-select').value;
				const filteredData = applyFilters(originalData, currentFilters);

				// Update stats
				const stats = {
					nodes: filteredData.nodes.length,
					hosts: filteredData.nodes.filter(n => n.data.type === 'host').length,
					containers: filteredData.nodes.filter(n => n.data.type === 'container').length,
					edges: filteredData.edges.length
				};

				document.getElementById('stat-nodes').textContent = stats.nodes;
				document.getElementById('stat-hosts').textContent = stats.hosts;
				document.getElementById('stat-containers').textContent = stats.containers;
				document.getElementById('stat-edges').textContent = stats.edges;

				// Recreate graph with filtered data
				if (cy) {
					cy.destroy();
				}

				cy = cytoscape({
					container: document.getElementById('cy'),
					elements: filteredData,
					style: [
						{
							selector: 'node',
							style: {
								'background-color': '#6366f1',
								'label': 'data(label)',
								'color': '#f1f5f9',
								'text-valign': 'center',
								'text-halign': 'center',
								'font-size': '12px',
								'width': 60,
								'height': 60,
								'border-width': 2,
								'border-color': '#8b5cf6'
							}
						},
						{
							selector: 'node[type="host"]',
							style: {
								'background-color': '#6366f1',
								'shape': 'rectangle',
								'width': 80,
								'height': 60,
								'border-color': '#4f46e5'
							}
						},
						{
							selector: 'node[type="container"]',
							style: {
								'background-color': '#10b981',
								'shape': 'ellipse',
								'width': 60,
								'height': 60
							}
						},
						{
							selector: 'node[status="stopped"]',
							style: {
								'background-color': '#94a3b8',
								'opacity': 0.7
							}
						},
						{
							selector: 'node[status="running"]',
							style: {
								'background-color': '#10b981'
							}
						},
						{
							selector: 'edge',
							style: {
								'width': 2,
								'line-color': '#475569',
								'target-arrow-color': '#475569',
								'target-arrow-shape': 'triangle',
								'curve-style': 'bezier',
								'arrow-scale': 1.5
							}
						},
						{
							selector: 'node:selected',
							style: {
								'border-width': 4,
								'border-color': '#f59e0b'
							}
						}
					],
					layout: {
						name: layout,
						animate: true,
						animationDuration: 500,
						fit: true,
						padding: 50,
						randomize: false,
						componentSpacing: 100,
						nodeRepulsion: 400000,
						idealEdgeLength: 100,
						edgeElasticity: 100
					}
				});

				// Re-add tooltips
				cy.on('tap', 'node', function(evt) {
					const node = evt.target;
					const data = node.data();
					let info = `Type: ${data.type}\\nID: ${data.id}\\nStatus: ${data.status || 'N/A'}`;
					if (data.type === 'host') {
						info += `\\nIP: ${data.ip || 'N/A'}\\nCPU: ${data.cpu || 'N/A'}\\nMemory: ${data.memory ? (data.memory / 1024 / 1024 / 1024).toFixed(1) + ' GB' : 'N/A'}`;
					} else if (data.type === 'container') {
						info += `\\nImage: ${data.image || 'N/A'}`;
					}
					alert(info);
				});
			}

			// Filter event listeners
			document.getElementById('filter-type').addEventListener('change', function(e) {
				currentFilters.type = e.target.value;
				reapplyFilters();
			});

			document.getElementById('filter-status').addEventListener('change', function(e) {
				currentFilters.status = e.target.value;
				reapplyFilters();
			});

			document.getElementById('filter-datacenter').addEventListener('change', function(e) {
				currentFilters.datacenter = e.target.value;
				reapplyFilters();
			});

			document.getElementById('btn-clear-filters').addEventListener('click', function() {
				currentFilters = { type: 'all', status: 'all', datacenter: 'all' };
				document.getElementById('filter-type').value = 'all';
				document.getElementById('filter-status').value = 'all';
				document.getElementById('filter-datacenter').value = 'all';
				reapplyFilters();
			});

			// WebSocket connection for real-time updates
			let ws = null;
			let wsReconnectAttempts = 0;
			const maxReconnectAttempts = 10;
			const reconnectDelay = 3000;

			function connectWebSocket() {
				const protocol = window.location.protocol === 'https:' ? 'wss:' : 'ws:';
				const wsURL = `${protocol}//${window.location.host}/api/v1/ws/graph`;

				try {
					ws = new WebSocket(wsURL);

					ws.onopen = function() {
						console.log('WebSocket connected');
						wsReconnectAttempts = 0;
						// Add connection indicator
						const indicator = document.createElement('div');
						indicator.id = 'ws-status';
						indicator.style.cssText = 'position: fixed; bottom: 20px; right: 20px; background: #10b981; color: white; padding: 8px 16px; border-radius: 4px; font-size: 14px; z-index: 1000;';
						indicator.textContent = '‚óè Connected';
						document.body.appendChild(indicator);
						setTimeout(() => indicator.remove(), 3000);
					};

					ws.onmessage = function(event) {
						try {
							const graphEvent = JSON.parse(event.data);
							console.log('WebSocket event received:', graphEvent);
							handleGraphEvent(graphEvent);
						} catch (error) {
							console.error('Failed to parse WebSocket message:', error);
						}
					};

					ws.onerror = function(error) {
						console.error('WebSocket error:', error);
					};

					ws.onclose = function() {
						console.log('WebSocket disconnected');
						// Remove connection indicator if exists
						const indicator = document.getElementById('ws-status');
						if (indicator) indicator.remove();

						// Attempt reconnection
						if (wsReconnectAttempts < maxReconnectAttempts) {
							wsReconnectAttempts++;
							console.log(`Reconnecting WebSocket (attempt ${wsReconnectAttempts}/${maxReconnectAttempts})...`);
							setTimeout(connectWebSocket, reconnectDelay);
						} else {
							console.error('Max WebSocket reconnection attempts reached');
						}
					};
				} catch (error) {
					console.error('Failed to create WebSocket connection:', error);
				}
			}

			function handleGraphEvent(event) {
				if (!cy) return;

				switch (event.type) {
					case 'container_added':
						handleContainerAdded(event.data);
						break;
					case 'container_updated':
						handleContainerUpdated(event.data);
						break;
					case 'container_removed':
						handleContainerRemoved(event.data);
						break;
					case 'host_added':
						handleHostAdded(event.data);
						break;
					case 'host_updated':
						handleHostUpdated(event.data);
						break;
					case 'host_removed':
						handleHostRemoved(event.data);
						break;
					case 'graph_refresh':
						// Refresh the entire graph
						const layout = document.getElementById('layout-select').value;
						initGraph(layout);
						break;
					default:
						console.warn('Unknown event type:', event.type);
				}

				// Update stats after any change
				updateStats();
			}

			function handleContainerAdded(container) {
				const nodeId = container['@id'] || container.id;

				// Check if node already exists
				if (cy.$('#' + nodeId).length > 0) {
					return;
				}

				// Add container node
				cy.add({
					data: {
						id: nodeId,
						label: container.name,
						type: 'container',
						status: container.status,
						image: container.image
					}
				});

				// Add edge to host if hostedOn exists
				if (container.hostedOn) {
					const hostId = container.hostedOn['@id'] || container.hostedOn;
					if (cy.$('#' + hostId).length > 0) {
						cy.add({
							data: {
								id: 'edge-' + nodeId,
								source: hostId,
								target: nodeId
							}
						});
					}
				}

				// Animate the new node
				cy.$('#' + nodeId).animate({
					style: { opacity: 1 }
				}, {
					duration: 500
				});

				// Re-layout the graph
				cy.layout({
					name: document.getElementById('layout-select').value,
					animate: true,
					animationDuration: 500,
					fit: false
				}).run();

				showNotification('Container added: ' + container.name, 'success');
			}

			function handleContainerUpdated(container) {
				const nodeId = container['@id'] || container.id;
				const node = cy.$('#' + nodeId);

				if (node.length > 0) {
					// Update node data
					node.data({
						label: container.name,
						status: container.status,
						image: container.image
					});

					// Flash animation
					node.animate({
						style: { 'border-width': '4px' }
					}, {
						duration: 300,
						complete: function() {
							node.animate({
								style: { 'border-width': '2px' }
							}, {
								duration: 300
							});
						}
					});

					showNotification('Container updated: ' + container.name, 'info');
				}
			}

			function handleContainerRemoved(data) {
				const nodeId = data.id;
				const node = cy.$('#' + nodeId);

				if (node.length > 0) {
					// Fade out animation
					node.animate({
						style: { opacity: 0 }
					}, {
						duration: 500,
						complete: function() {
							// Remove node and connected edges
							node.remove();
							cy.$('#edge-' + nodeId).remove();
						}
					});

					showNotification('Container removed', 'warning');
				}
			}

			function handleHostAdded(host) {
				const nodeId = host['@id'] || host.id;

				// Check if node already exists
				if (cy.$('#' + nodeId).length > 0) {
					return;
				}

				// Add host node
				cy.add({
					data: {
						id: nodeId,
						label: host.name,
						type: 'host',
						status: host.status,
						ip: host.ipAddress,
						cpu: host.cpuCores,
						memory: host.memoryBytes
					}
				});

				// Animate the new node
				cy.$('#' + nodeId).animate({
					style: { opacity: 1 }
				}, {
					duration: 500
				});

				// Re-layout the graph
				cy.layout({
					name: document.getElementById('layout-select').value,
					animate: true,
					animationDuration: 500,
					fit: false
				}).run();

				showNotification('Host added: ' + host.name, 'success');
			}

			function handleHostUpdated(host) {
				const nodeId = host['@id'] || host.id;
				const node = cy.$('#' + nodeId);

				if (node.length > 0) {
					// Update node data
					node.data({
						label: host.name,
						status: host.status,
						ip: host.ipAddress,
						cpu: host.cpuCores,
						memory: host.memoryBytes
					});

					// Flash animation
					node.animate({
						style: { 'border-width': '6px' }
					}, {
						duration: 300,
						complete: function() {
							node.animate({
								style: { 'border-width': '3px' }
							}, {
								duration: 300
							});
						}
					});

					showNotification('Host updated: ' + host.name, 'info');
				}
			}

			function handleHostRemoved(data) {
				const nodeId = data.id;
				const node = cy.$('#' + nodeId);

				if (node.length > 0) {
					// Get all containers connected to this host
					const connectedContainers = cy.$('#' + nodeId).neighborhood('node[type="container"]');

					// Fade out animation for host and containers
					node.add(connectedContainers).animate({
						style: { opacity: 0 }
					}, {
						duration: 500,
						complete: function() {
							// Remove host, containers, and edges
							node.add(connectedContainers).remove();
						}
					});

					showNotification('Host removed', 'warning');
				}
			}

			function updateStats() {
				if (!cy) return;

				const hosts = cy.nodes('[type="host"]').length;
				const containers = cy.nodes('[type="container"]').length;
				const edges = cy.edges().length;

				document.getElementById('node-count').textContent = hosts + containers;
				document.getElementById('edge-count').textContent = edges;
			}

			function showNotification(message, type = 'info') {
				const colors = {
					success: '#10b981',
					info: '#3b82f6',
					warning: '#f59e0b',
					error: '#ef4444'
				};

				const notification = document.createElement('div');
				notification.style.cssText = `
					position: fixed;
					bottom: 20px;
					right: 20px;
					background: ${colors[type]};
					color: white;
					padding: 12px 20px;
					border-radius: 4px;
					font-size: 14px;
					z-index: 1000;
					box-shadow: 0 4px 6px rgba(0, 0, 0, 0.1);
					animation: slideIn 0.3s ease-out;
				`;
				notification.textContent = message;
				document.body.appendChild(notification);

				setTimeout(() => {
					notification.style.animation = 'slideOut 0.3s ease-in';
					setTimeout(() => notification.remove(), 300);
				}, 3000);
			}

			// Initialize graph on page load
			initGraph();

			// Connect WebSocket after graph is initialized
			setTimeout(connectWebSocket, 1000);
		})();
		</script>
	}
}
